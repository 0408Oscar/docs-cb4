
<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
<head><meta name="description" content="You can use the CAS value to control how concurrent document modifications are handled The CAS is a value representing the current state of an item. Each time the item is modified, its CAS changes. ..."></meta><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta><meta name="copyright" content="(C) Copyright 2005"></meta><meta name="DC.rights.owner" content="(C) Copyright 2005"></meta><meta name="DC.Type" content="concept"></meta><meta name="DC.Title" content="Concurrent mutations"></meta><meta name="abstract" content="You can use the CAS value to control how concurrent document modifications are handled"></meta><meta name="description" content="You can use the CAS value to control how concurrent document modifications are handled"></meta><meta name="DC.Relation" scheme="URI" content="managing-data.html"></meta><meta name="DC.Format" content="XHTML"></meta><meta name="DC.Identifier" content="concept_iq4_bts_zs"></meta><link rel="stylesheet" type="text/css" href="oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>Concurrent mutations</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta><link rel="stylesheet" type="text/css" href="oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="oxygen-webhelp/resources/skins/skin.css"><!----></link><script type="text/javascript"><!--
          
          var prefix = "index.html";
          
          --></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery-1.8.2.min.js"><!----></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="concept_iq4_bts_zs">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><a href="javascript:window.print();" title="Print this page"></a></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td width="75%"><a class="navheader_parent_path" href="c-intro.html" title="C SDK 2.6">C SDK 2.6</a> / <a class="navheader_parent_path" href="managing-data.html" title="Managing Data">Managing Data</a></td><td><div class="navheader">
<span class="navparent"><a class="link" href="managing-data.html" title="Managing Data"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">Managing Data</span></a></span>  </div></td></tr></tbody></table>

    <h1 class="title topictitle1">Concurrent mutations</h1>

    
    <div class="body conbody"><p class="shortdesc">You can use the CAS value to control how concurrent document modifications are
        handled</p>

        <p class="p">The <dfn class="term">CAS</dfn> is a value representing the current state of an item. Each time the item
            is modified, its CAS changes.</p>

        <p class="p">The CAS value itself is returned as part of a document’s metadata whenever a document is
            accessed. In the SDK this is present as the <span class="keyword apiname">lcb_RESPBASE::cas</span> field
            when an operation is successful.</p>

        <div class="p">CAS is an acronym for <em class="ph i">Compare And Swap</em>, and is known as a form of optimistic
            locking. The CAS can be supplied as parameters to the <em class="ph i">insert</em>, <em class="ph i">upsert</em>,
                <em class="ph i">replace</em>, and <em class="ph i">remove</em> operations. When applications provide the CAS,
            server will check the application-provided version of CAS against its own version of the
                CAS:<ul class="ul" id="concept_iq4_bts_zs__ul_cxq_3ts_zs">
                <li class="li">If the two CAS values match (they compare successfully), then the mutation
                    operation succeeds.</li>

                <li class="li">If the two CAS values differ, then the mutation operation fails </li>

            </ul>
</div>

        <div class="section"><h2 class="title sectiontitle">Demonstration</h2>The following demonstrates how the server handles CAS.
            A use case for employing the CAS is when adding a new field to an existing document. At
            the application level, this requires the following steps:<ol class="ol" id="concept_iq4_bts_zs__ul_ehb_nts_zs">
                <li class="li">Read entire document.</li>

                <li class="li">Perform modification locally.</li>

                <li class="li">Store new document to server.</li>

            </ol>

            <div class="p">Assume the following two blocks of code are executing concurrently in different
                application instances: 
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="concept_iq4_bts_zs__table_x23_rts_zs" class="table" frame="border" border="1" rules="all"><caption><span class="tablecap">Table 1. CAS flow</span></caption>
                        
                        
                        <thead class="thead" align="left">
                            <tr class="row">
                                <th class="entry" valign="top" id="d343e87">Thread #1</th>

                                <th class="entry" valign="top" id="d343e90">Thread #2</th>

                            </tr>

                        </thead>

                        <tbody class="tbody">
                            <tr class="row">
                                <td class="entry" valign="top" headers="d343e87 ">
                                    <pre class="pre codeblock">&gt;&gt;&gt; result = cb1.get('docid')
&gt;&gt;&gt; new_doc = result.value
&gt;&gt;&gt; new_doc['field1'] = 'value1'
&gt;&gt;&gt; cb1.replace('docid', new_doc)</pre>

                                </td>

                                <td class="entry" valign="top" headers="d343e90 ">
                                    <pre class="pre codeblock">&gt;&gt;&gt; result = cb2.get('docid')
&gt;&gt;&gt; new_doc = result.value
&gt;&gt;&gt; new_doc['field2'] = 'value2'
&gt;&gt;&gt; cb2.replace('docid', new_doc)</pre>

                                </td>

                            </tr>

                        </tbody>

                    </table>
</div>
Retrieving the document again
                yields:<pre class="pre codeblock">&gt;&gt;&gt; cb1.get('docid').value
{u'field2': u'value2', u'a_field': u'a_value'}</pre>
</div>
<p class="p">Note
    that <samp class="ph codeph">field1</samp> is not present, even though the application inserted it
    into the document. The reason is because the replace on Thread #2 happened to run
    after the replace on Thread #1, however Thread #1’s replace was executed after
    Thread #2’s get: Since the local version of the document on Thread #2 did not
    contain field1 (because Thread #1’s update was not stored on the server yet), by
    executing the replace, it essentially overrode the replace performed by Thread
    #1.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="concept_iq4_bts_zs__table_jvd_b5s_zs" class="table" frame="border" border="1" rules="all">
            
            
            <tbody class="tbody">
                <tr class="row">
                    <td class="entry" dir="ltr" valign="top" width="6.5019505851755515%">0.00ms</td>

                    <td class="entry" dir="ltr" valign="top" width="93.49804941482445%">(#2): <samp class="ph codeph">new_doc =
                        get(‘docid’).value</samp></td>

                </tr>

                <tr class="row">
                    <td class="entry" dir="ltr" valign="top" width="6.5019505851755515%">0.00ms</td>

                    <td class="entry" dir="ltr" valign="top" width="93.49804941482445%">(#1): <samp class="ph codeph">new_doc =
                        get(‘docid’).value</samp></td>

                </tr>

                <tr class="row">
                    <td class="entry" dir="ltr" valign="top" width="6.5019505851755515%">0.00ms</td>

                    <td class="entry" dir="ltr" valign="top" width="93.49804941482445%">(#1): <samp class="ph codeph">new_doc[‘field1’] =
                        ‘value1’</samp></td>

                </tr>

                <tr class="row">
                    <td class="entry" dir="ltr" valign="top" width="6.5019505851755515%">0.00ms</td>

                    <td class="entry" dir="ltr" valign="top" width="93.49804941482445%">(#2): <samp class="ph codeph">new_doc[‘field2’] =
                        ‘value2’</samp></td>

                </tr>

                <tr class="row">
                    <td class="entry" dir="ltr" valign="top" width="6.5019505851755515%">0.01ms</td>

                    <td class="entry" dir="ltr" valign="top" width="93.49804941482445%">(#1): <samp class="ph codeph">cb.replace(‘docid’,
                        new_doc)</samp></td>

                </tr>

                <tr class="row">
                    <td class="entry" dir="ltr" valign="top" width="6.5019505851755515%">0.02ms</td>

                    <td class="entry" dir="ltr" valign="top" width="93.49804941482445%">(#2): <samp class="ph codeph">cb.replace(‘docid’,
                        new_doc)</samp></td>

                </tr>

            </tbody>

        </table>
</div>
</div>

        <div class="section"><h2 class="title sectiontitle">Using CAS - Example</h2>
            
            <div class="p">In the prior example, we saw that concurrent updates to the same document may result
                in some updates being lost. This is not because Couchbase itself has lost the updates,
                but because the application was unaware of newer changes made to the document and
                inadvertently override them.
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="concept_iq4_bts_zs__table_fw1_m5s_zs" class="table" frame="border" border="1" rules="all"><caption><span class="tablecap">Table 2. CAS flow</span></caption>
                        
                        
                        <thead class="thead" align="left">
                            <tr class="row">
                                <th class="entry" valign="top" width="50%" id="d343e224"> </th>

                                <th class="entry" valign="top" width="50%" id="d343e226"> </th>

                            </tr>

                        </thead>

                        <tbody class="tbody">
                            <tr class="row">
                                <td class="entry" valign="top" width="50%" headers="d343e224 ">
                                    <pre class="pre screen">
&gt;&gt;&gt; result = cb1.get('docid')
&gt;&gt;&gt; new_doc = result.value
&gt;&gt;&gt; print new_doc
{u'a_field': u'a_value'}
&gt;&gt;&gt; <strong class="ph b">cur_cas = result.cas</strong>
&gt;&gt;&gt; print cur_cas
272002471883283
&gt;&gt;&gt; new_doc['field1'] = 'value1'
&gt;&gt;&gt; new_result = cb1.replace(
       'docid',
       new_doc,
       cas=cur_cas)</pre>

                                    <div class="note note"><span class="notetitle">Note:</span> Server's CAS matches <samp class="ph codeph">cur_cas</samp>. New CAS
                                        assigned</div>

                                    <pre class="pre screen">&gt;&gt;&gt; print new_result.cas
195896137937427</pre>

                                </td>

                                <td class="entry" valign="top" width="50%" headers="d343e226 ">
                                    <pre class="pre screen">&gt;&gt;&gt; result = cb2.get('docid')
&gt;&gt;&gt; new_doc = result.value
&gt;&gt;&gt; print new_doc
{u'a_field': u'a_value'}
&gt;&gt;&gt; <strong class="ph b">cur_cas = result.cas</strong>
&gt;&gt;&gt; print cur_cas
272002471883283
&gt;&gt;&gt; new_doc['field2'] = 'value2'
&gt;&gt;&gt; new_result = cb2.replace(
       'docid',
       new_doc,
       cas=cur_cas)</pre>

                                    <div class="note warning"><span class="warningtitle">Warning:</span> CAS on server differs:
                                        <samp class="ph codeph">195896137937427</samp> vs
                                        <samp class="ph codeph">272002471883283</samp>!</div>

                                </td>

                            </tr>

                        </tbody>

                    </table>
</div>
</div>

        </div>

        <div class="section"><h2 class="title sectiontitle">Handling CAS errors</h2>
            
            <div class="p">If the item’s CAS has changed since the last operation performed by the current
                client (i.e. the document has been changed by another client), the CAS used by the
                application is considered <em class="ph i">stale</em>. If a <em class="ph i">stale</em> CAS is sent to the server
                (via one of the mutation commands, as above), the server will reply with an error,
                and the Couchbase SDK will accordingly return this error to the application (either
                via return code or exception, depending on the language).<div class="note note"><span class="notetitle">Note:</span> The error returned
                    for a CAS mismatch is the same that is returned when trying to insert an
                    already-existing document. The error code is not ambiguous since the CAS option
                    is only accepted (and only makes sense) for documents which already
                    exist.</div>
</div>

            <div class="p">How to handle this error depends on the application logic. If the application wishes
                to simply insert a new property within the document (which is not dependent on other
                properties within the document), then it may simply retry the read-update cycle by
                retrieving the item (and thus getting the new CAS), performing the local
                modification and then uploading the change to the server. For example, if a document
                represents a user, and the application is simply updating a user’s information (like
                an email field), the method to update this information may look like
                this:<pre class="pre codeblock">def update_email(cb, user_id, email):
    while True:
        result = cb.get(user_id)
        user_doc = result.value
        user_doc['email'] = email
        cb.upsert(user_id, user_doc, cas=result.cas)
        break # Mutation succeeded
    except KeyExistsError:
        # This means the CAS has been modified. We still need to
        # insert the email field, but do not want to override new changes
        continue</pre>
</div>

            <p class="p">Sometimes more logic is needed when performing updates, for example, if a property is
                mutually exclusive with another property; only one or the other can exist, but not
                both.</p>

        </div>

        <div class="section"><h2 class="title sectiontitle">Performance considerations</h2>
            
            <p class="p">CAS operations incur no additional overhead. CAS values are always returned from the
                server for each operation. Comparing CAS at the server involves a simple integer
                comparison which incurs no overhead.</p>

        </div>

        <div class="section"><h2 class="title sectiontitle">CAS value format</h2>
            
            <p class="p">The CAS value should be treated as an opaque object at the application level. No
                assumptions should be made with respect to how the value is changed (for example, it
                is wrong to assume that it is a simple counter value). In the SDK, the CAS is
                represented as a 64 bit integer for efficient copying but should otherwise be
                treated as an opaque 8 byte buffer.</p>

        </div>

        <div class="section"><h2 class="title sectiontitle">Pessimistic locking</h2>
            
            <p class="p">While CAS is the recommended way to perform locking and concurrency control,
                Couchbase also offers explicit <em class="ph i">locking</em>. When a document is locked, attempts
                to mutate it without supplying the correct CAS will fail.</p>

            <p class="p">Documents can be locked using the <em class="ph i">get-and-lock</em> operation and unlocked either
                explicitly using the <em class="ph i">unlock</em> operation or implicitly by mutating the document
                with a valid CAS. While a document is locked, it may be retrieved but not modified
                without using the correct CAS value. When a locked document is retrieved, the server
                will return <samp class="ph codeph">-1</samp> (or <samp class="ph codeph">0xffffffffffffffff</samp>) as the CAS
                value.</p>

            <p class="p">A document can be locked for a maximum of 15 seconds, after which the server will
                unlock it. This is to prevent misbehaving applications from blocking access to
                documents inadvetrtantly. You can modify the time the lock is held for (though it
                can be no longer than 15 seconds).</p>

            <div class="p">Be sure to keep note of the <em class="ph i">cas</em> value when locking a document. You will need
                it when
                unlocking.<pre class="pre codeblock">lcb_CMDGET cmd = { 0 };
LCB_CMD_SET_KEY(&amp;cmd, "key", 3);
cmd.lock = 1;
cmd.exptime = 5;
lcb_get3(instance, NULL, &amp;cmd);
lcb_wait(instance);</pre>
<pre class="pre codeblock">static int unlock_only = 0;

void get_handler(lcb_t instance, int cbtype, const lcb_RESPBASE *rb)
{
    const lcb_RESPGET *resp = (const lcb_RESPGET *)rb;

    union {
        lcb_CMDBASE base;
        lcb_CMDSTORE store;
        lcb_CMDUNLOCK unlock;
    } u;

    if (rb-&gt;rc == LCB_ETMPFAIL) {
        printf("Key already locked!");
    } else if (rb-&gt;rc == LCB_SUCCESS) {
        memset(&amp;u, 0, sizeof u);
        LCB_CMD_SET_KEY(&amp;u.base, rb-&gt;key, rb-&gt;nkey);
        u.base.cas = rb-&gt;cas;
        if (unlock_only) {
            lcb_unlock3(instance, NULL, &amp;u.unlock);
        } else {
            LCB_CMD_SET_VALUE(&amp;u.store, "value", 5);
            u.store.operation = LCB_REPLACE;
            lcb_store3(instance, NULL, &amp;u.store);
        }
    }
}</pre>
The
                handler will unlock the item either via an explicit unlock operation
                    (<span class="keyword apiname">lcb_unlock3</span>) or implicitly via modifying the item with the
                correct CAS.</div>

            <p class="p">If the item has already been locked, the server will respond with
                    <var class="keyword varname">LCB_ETMPFAIL</var> which means that the operation could not be
                executed temporarily, but may succeed later on.</p>

        </div>

    </div>

<div class="related-links"></div>
<div class="navfooter"><!---->
<span class="navparent"><a class="link" href="managing-data.html" title="Managing Data"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">Managing Data</span></a></span>  </div><div class="footer">WebHelp output generated by<a href="http://www.oxygenxml.com" target="_blank"><span class="oXygenLogo"><img src="oxygen-webhelp/resources/img/LogoOxygen100x22.png" alt="Oxygen"></img></span><span class="xmlauthor">XML Author</span></a> - Trial Edition</div>
</body>
</html>