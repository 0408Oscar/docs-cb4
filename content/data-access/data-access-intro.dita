<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="concept_ul5_45f_ps">
 <title>Data access</title>
	<shortdesc>
	 Couchbase offers multiple ways to access data: by issuing N1QL queries, by querying MapReduce views, by querying spatial views, and by key-value operations that allow fast direct access to documents using their unique identifiers.  </shortdesc>
 <conbody>
  <p>Couchbase does not restrict you to choose a single access method as N1QL queries, key-value, and MapReduce data access can all co-exist within the same application and Couchbase SDK.  </p>
  <section> <title> SQL query support (N1QL)</title>
   <p>Couchbase Server can be programmed using SQL. Given that nearly all programmers already know SQL, most developers will be able to get started quickly on Couchbase. And since most organizations already have significant amounts of SQL code, Couchbase Server fits into the technology landscape more easily.  Support for SQL by JDBC and ODBC drivers opens the ecosystem of tools for analytics and data integration such as Microsoft Excel and Tableau.</p>
   <p>Couchbase created its own SQL dialect called N1QL in order to give developers and enterprises an expressive, powerful, and complete language for querying, transforming, and manipulating JSON data. The N1QL query engine is optimized for modern, highly parallel multi-core execution. N1QL has special extensions that allow it to deal with documents with variable and/or nested structures.  Just as SQL operates on rows, columns and tables of an RDBMS and returns rows and columns to the application, N1QL operates on JSON and returns JSON to the application.
   </p>
   <p>N1QL provides a full range of functionality immediately familiar to anyone who has used SQL. N1QL can even query across document relationships. 
    <ul>
     <li>SELECT statements for queries and sub-queries</li>
     <li>UPDATE, UPSERT, INSERT, DELETE statements 
      <p><b>[These statements are experimental; it's not for use in production.]</b></p></li>
    <li>JOIN clauses to combine results from multiple documents into a single set</li>
    <li>WHERE clauses to define filters that narrow query selectivity and constrain UPDATE, UPSERT, INSERT and DELETE statements</li>
    <li>Aliases to rename elements for convenience and clarity</li>
    <li>Transformations such as GROUP BY, ORDER BY, LIMIT and OFFSET</li>
    <li>Both distinct and non-distinct set operators UNION,</li> 
    <li>Aggregate functions such as AVG, SUM, MAX, and COUNT</li>
    <li>A full range of expressions including string comparisons with LIKE and string operators such as UPPER and SUBSTR</li>
    <li>Prepared statements that get and cache a query plan independently of query execution, eliminating unnecessary work and therefore lowering query latency</li>
   </ul>
   </p>
   <p>N1QL also has extensions to SQL that enable it to better express the semantics of processing  JSON, which is more varied and flexible than RDBMS schemas and which has more embedded structure. N1QL’s extensions to SQL reduce application-side complexity of post-processing and filtering the query results, and also reduce the load on the network by transmitting less data:
    <ul>
     <li>Paths expressed with dot notation to address embedded JSON elements like arrays and objects. Paths work with both named attributes and numbered indexes. For example, route.schedule[0].day returns just the day of the first schedule object in an array.</li>
     <li>NEST and UNNEST commands to either construct or flatten an array in a query result, such as a user might do to create a clean list of items to display in a web page. NEST and UNNEST can be chained with JOIN in any combination.</li>
     <li>USE KEYS bypasses the index scan to directly access one or more documents using a primary key lookup. Because the hash of the key is used to physically place data on the appropriate Couchbase node, the request can be completed without any other lookup. This makes USE KEYS operations extremely fast, nearly as fast as a Couchbase Key-Value operation.</li>
     <li>JOIN… ON KEYS… As in use keys, the JOIN can be fulfilled by direct access, using a highly efficient nested loop join algorithm.</li>
     <li>Ranging over collections with operators ANY and EVERY to check the members of an array that meet a particular condition.</li>
     <li>Mapping with filtering using the ARRAY command</li>
     <li>WITHIN walks a hierarchical JSON structure of arbitrary depth. Can be combined with SET and UNSET commands to add or remove nodes in the hierarchy. </li>
     <li>Dynamic JSON object construction using the result of a query.</li>
     <li>N1QL supports nested traversal of structures so that queries can “see” and directly address parts of documents including embedded properties and arrays.</li>
     <li>MISSING, a special query value that indicates the lack of a given field within a document. Unlike relational databases, Couchbase Server documents can simply omit properties that are not applicable rather than being forced to include them for consistency and setting them to NULL. Since NULL is also a valid data type in JSON, MISSING allows programmers to express different handling for each case if they so choose.</li>
    </ul>
   </p>
   <p>N1QL also has a set of functions to help with querying:
    <ul>
     <li>Date functions which will convert a date string into something which can be sorted and/or compared in a query</li>
    <li>Regular expressions; a more powerful form of LIKE</li>
    <li>String concatenation functions</li>
    <li>Type coercion (for example, to parse a string as a number)</li>
    </ul>
  </p>
   <p>
    N1QL uses native JSON data types for Numbers, Strings, Boolean, Null, Arrays, and Objects. In addition, N1QL also supports binary types as required to inter-operate with the Key-Value store, as well as MISSING, mentioned above. All data types have well defined semantics for comparison, sort order, date handling, and more. 
    An interactive N1QL shell, called <cmdname>cbq</cmdname>, can be used to quickly issue queries and examine their results. An interactive tutorial is built into the query server itself as well.
   </p>
   <p>For more information about N1QL, see <xref href="../n1ql/n1ql.ditamap">N1QL reference</xref>.</p>
  </section>
  <section> <title> Key-Value operations</title>
  <p>
   At the heart of Couchbase is the distributed Key-Value (KV) store. The KV store provides an extremely simple and fast mechanism by which to store data. A KV store is a simple, schema-less approach to data management that, as the name implies, involves storing a unique ID (key) with a piece of arbitrary information (value); it may be thought of as a hashmap or dictionary. The KV store itself can accept any data, whether it be a binary blob or a JSON document, and Couchbase features such as N1QL and MapReduce make use of the KV store’s ability to process JSON documents. </p>
   <p>Due to their simplicity, KV operations execute with extremely low latency, often sub-millisecond. While the Query service is accessed by a defined query language (N1QL), the KV store is accessed using simple CRUD (Create, Read, Update, Delete) APIs, and thus provides a simpler interface when accessing documents using their IDs (primary keys).</p>
   <p>The KV store contains the authoritative, most up-to-date state for each item. In order to
    perform better, query and MapReduce services provide eventually consistent indexes that, by
    default, use a potentially slightly out of date version of the data. However, they can instead
    elect to wait slightly to make sure they have had a chance to update before responding to a
    query. Querying the KV store directly however will always access the latest version of data.</p>
   
   <p>While N1QL may often provide a richer query interface, applications will use the KV store when speed, consistency,  and simplified access patterns are preferred over flexible query options.</p>
   
   <p>All KV operations are atomic, which means that Read and Update are individual operations. In order to avoid conflicts that might arise with multiple concurrent updates to the same document, applications may make use of CAS, which is a per-document checksum that Couchbase modifies each time a document is changed), called CAS, to avoid conflicts with multiple concurrent updates to the same document.
  </p>
  </section>
  <section> <title> MapReduce views</title>
   <p> Programmers can write JavaScript MapReduce programs that create views of items stored in
    Couchbase, called MapReduce views for short. MapReduce is a programming model for distributed
    data processing on highly parallelizable data: the map function reads all documents across the
    cluster, filters them to select the relevant information, and then emits the results; reduce
    function sorts and aggregates the results. Once created, MapReduce views are incrementally
    updated automatically as their underlying data undergoes mutations. MapReduce views can be
    queried using REST API endpoints, client SDKs, or N1QL queries. </p>
   <p>The main strength of MapReduce views compared to other indexes is that their ability to be customize and their flexibility allow MapReduce views to handle complex computations and very large datasets. Once created, they are incrementally updated automatically. When MapReduce views contain keys in their outputs, they can serve as indexes and are discussed further in the indexes section.
   </p></section>
  <section> <title> Spatial views</title>
   <p>
    Spatial Views are a special type of MapReduce View that can be created to enable queries about  geometries, such as whether a point is located within a  bounding box. Spatial views take as input geometric data in the form of GeoJSON,  n-dimensional numeric data (hyper-cubes), or a combination of the two. Spatial views are a special form of MapReduce view. They are typically leveraged as spatial indexes.
   </p></section>
  <section> <title> Full text search</title>
   <p> Couchbase Server performs search queries using <xref
     href="https://github.com/couchbaselabs/cbft" format="html" scope="external">Couchbase
     FTS</xref> (Developer Preview), an integrated full text search engine. With Couchbase full text search, you, as a developer,
    can easily add full-text search capabilities to your application without deploying additional
    components, which reduces operational complexity. Alternatively, if you are using external
    search engines such as Elasticsearch or Lucidworks, you can leverage the available <xref href="../connectors/intro.dita">connectors</xref> to
    continuously replicate data from the Couchbase Server cluster to the search engines. </p></section>
 </conbody>
</concept>
