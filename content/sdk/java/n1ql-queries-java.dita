<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="java-n1ql">
    <title>N1QL from the SDK</title>
    <shortdesc>You can perform N1QL queries via the Java
        client.</shortdesc>
    <conbody>
        <note>See Couchbase Developer documentation for a quick intro to N1QL: &lt;XXX></note>

        <p>
            To issue N1QL queries, you should create a <apiname>N1qlQuery</apiname> object, and pass it to the <apiname>query(N1qlQuery q)</apiname> method in the <apiname>Bucket</apiname> class.
            A few variants of such a query exist: simple queries (that is, ones that are only strings and do not use placeholders), parameterized queries (using numered or named placeholders)...
            Each can be created via the corresponding factory method on <apiname>N1qlQuery</apiname>.
            They can be created with a <apiname>Statement</apiname> produced by the N1QL DSL, or the statement can be supplied as a <apiname>String</apiname> directly.
        </p>
        <p>
            The return value from <apiname>query()</apiname> is a <apiname>N1qlQueryResult</apiname> object.
            Iterating over the object will yield the rows returned by the server for the given query (as a <codeph>N1qlQueryRow</codeph>).
            Each row represents a row received for the query.
        </p>
        <p>
            Additionally, you can get the <apiname>List&lt;N1qlQueryRow&gt;</apiname> from the <apiname>allRows()</apiname> method on the result.
            Note that errors returned by the N1QL service during execution are represented as <apiname>JsonObject</apiname> accessible through the <apiname>errors()</apiname> method, rather than exceptions.
            Here is the complete list of <apiname>N1qlQueryResult</apiname> methods:
        </p>
        <p><ul>
            <li>
                <codeph>parseSuccess</codeph>: Returns true if the query could correctly be parsed.
                This information is available immediately even if the actual list of results takes more time to be computed and streamed to the client.
            </li> <li>
                <codeph>finalSuccess</codeph>: Returns true if the whole query could be executed successfully, including retrieving all the results and streaming them to the client.
            </li> <li>
                <codeph>allRows</codeph>: Contains all rows returned by the query, can be an empty list.
            </li> <li>
                <codeph>rows</codeph>: Same as <codeph>allRows</codeph> but in an iterator form (the <apiname>N1qlQueryResult</apiname> itself is iterable).
            </li> <li>
                <codeph>requestId</codeph>: The server-generated unique ID for this query (useful to find associated logs on the N1QL server).
            </li> <li>
                <codeph>clientContextId</codeph>: User-provided identifier reflected in the server's response. This can be useful to group several queries (for example, in a kind of in-house transaction) and find all associated queries.
            </li> <li>
                <codeph>info</codeph>: Returns a <apiname>N1qlMetrics</apiname> object containing metrics for the query (like number of results or processing time).
            </li> <li>
                <codeph>errors</codeph>: Returns a list of <apiname>JsonObject</apiname> describing errors or warnings (if any occurred during execution).
            </li>
        </ul></p>
        <p>
            Each <apiname>N1qlQueryRow</apiname> exposes the JSON representation of the <codeph>value()</codeph>, as a <apiname>JsonObject</apiname>, but also the raw bytes for said value (<codeph>rawValue()</codeph>), in case you need them to apply your own deserialization.
        </p>
        <p>
            You can use N1QL placeholders in the query.
            Placeholders allow you to specify variable constraints for an otherwise constant query.
            To use placeholders, manually construct an N1QLQuery object with the base query string, and simply use a <apiname>JsonObject</apiname> of names -> keyword or a <apiname>JsonArray</apiname> of positional arguments for named or positional placeholders, respectively:
            <codeblock outputclass="language-java" spectitle="N1QL Query with placeholders">import static com.couchbase.client.java.query.Select.select;
import static com.couchbase.client.java.query.dsl.Expression.*;

// ...
Statement statement = select("fname", "lname", "age").from(i("default")).where(x("age").gt(x("$age")));
JsonObject placeholderValues = JsonObject.create().put("age", 22);
q = N1qlQuery.parameterized(statement, placeholderValues);
for (N1qlQueryRow row : bkt.query(q)) {
    System.out.println(row);
}</codeblock>
        </p>



        <section><title>Building Statements with the DSL</title>
            <p>
                The N1QL domain-specific language (DSL) is a powerful way to guide you in building your statements: you get type safety and autocompletion of relevant methods / N1QL clauses.
            </p>
            <p>
                As of the <codeph>2.2.3</codeph> version of the SDK, the DSL supports the following features:
                <ul>
                    <li>Data selection with <apiname>Select.select(...)</apiname> as an entry point (including index hinting)</li>
                    <li>All N1QL functions, organized by topic in the helper classes in the <apiname>com.couchbase.client.java.query.dsl.functions</apiname> package (eg. <apiname>AggregateFunctions</apiname>)</li>
                    <li>A <xref href="#java-n1ql/case">mini DSL for building CASE constructs</xref > via factory methods on the <apiname>Case</apiname> class</li>
                    <li>A <xref href="#java-n1ql/collections">mini DSL for building collection constructs</xref > (ANY, EVERY, ARRAY...) via factory methods on the  <apiname>Collections</apiname> class</li>
                    <li>Index management (index and primary index creation/deletion/deferred building) with <apiname>Index</apiname> factory methods as an entry point</li>
                    <li>Data modification with <apiname>Insert</apiname>, <apiname>Update</apiname>, <apiname>Upsert</apiname> and <apiname>Delete</apiname> as entry points.</li>
                </ul>
            </p>
            <p>
                To construct statements, you can use the <apiname>Expression</apiname> class that comes in with a variety of factory methods to construct both tokens and literals programmatically.
                Expressions can be combined and chained with operators (like <apiname>gte</apiname> for "greater than or equal to" comparison...).
            </p>
            <p>
                Use <apiname>x</apiname> to construct a token, <apiname>s</apiname> to construct a string literal, <apiname>i</apiname> to construct a token escaped with backticks (for instance the bucket name <codeph>beer-sample</codeph> must be escaped because it contains a dash).
            </p>
            <p>
                Additionally, if you find the DSL doesn't support a particular statement, clause or keyword, <b>you can always revert to providing your statement in plain String form</b>.
                This ensures that even if the DSL somehow lags behind the evolutions of the language, users will always have a mean of using new language features.
            </p>
        </section>



        <section><title>Querying Asynchronously</title>
            <p>
                Querying asynchronously is done through the <apiname>AsyncBucket</apiname> interface, obtained by calling <apiname>bucket.async()</apiname>.
                The API is pretty similar except everything is returned as an <apiname>Observable</apiname>.
                Some of the components of the query result (an <apiname>AsyncQueryResult</apiname>) can also be delayed and so returned as Observables.
                Only <apiname>requestId</apiname>, <apiname>clientContextId</apiname> and <apiname>parseSuccess</apiname> return immediately.
            </p>
            <p>
                The following Java 8 code prints the found documents or errors as they come:
            </p>
<codeblock outputclass="language-java"><![CDATA[bucket.async()
    .query(select("*").from(i("beer-sample")).limit(10))
    .flatMap(result ->
        result.errors()
        .flatMap(e -> Observable.<AsyncN1qlQueryRow>error(new CouchbaseException("N1QL Error/Warning: " + e)))
        .switchIfEmpty(result.rows())
    )
    .map(AsyncN1qlQueryRow::value)
    .subscribe(
        rowContent -> System.out.println(rowContent),
        runtimeError -> runtimeError.printStackTrace()
    );]]></codeblock>
            <p>
                First, you can see that asynchronous mode is used.
                Second line issues a <apiname>Statement</apiname> using the DSL (notice how "beer-sample" is escaped).
                When receiving a result, we'll first check if there are errors.
                If there is any, the first one is converted to a <apiname>CouchbaseException</apiname> that will be propagated in the <apiname>Observable</apiname>.
                If no error is found (<apiname>errors()</apiname> is empty), we switch to inspecting the rows, then we map each received row to its JSON value.
            </p>
            <p>
                Eventually, we trigger the whole process by subscribing to the <apiname>Observable</apiname> we built.
                When a row JSON is received, we'll print it.
                When an error is propagated, we'll print the stack trace.
            </p>
            <p>
                <i>Note: All this is done asynchronously so it's not suitable for a simple test (where the main thread would exit potentially before any result could have been displayed)</i>
            </p>
        </section>



        <section id="case">
            <title>Conditionals, Case Expressions Mini DSL</title>
            <p>
                The <apiname>com.couchbase.client.java.query.dsl.functions.Case</apiname> class contains a mini-DSL to deal with Conditional operators in N1QL of the <codeph>CASE</codeph> family.
            </p>
            <p>
                The <codeph>Simple CASE</codeph> expression is defined as:
            </p>
<codeblock outputclass="language-sql"><![CDATA[CASE expression  ( WHEN expression THEN expression)
[ ( WHEN expression THEN expression) ]*
[  ELSE expression ]  END]]></codeblock>
            <p>
                The <codeph>Searched CASE</codeph> expression is defined as:
            </p>
<codeblock outputclass="language-sql"><![CDATA[CASE  ( WHEN  condition THEN expression)
[( WHEN  condition THEN expression ) ]*
[ ELSE  expression ] END ]]></codeblock>
            <p>
                The corresponding mini-DSL are <apiname>Case.caseSimple</apiname> and <apiname>Case.caseSearch</apiname>. Simple Case will compare the initial expression with each WHEN clause for equality, returning the corresponding THEN expression if a match is found. Search Case allows to have a different condition for each WHEN clause.
                Let's see two examples. First one could be used to map match results to a score:
            </p>
<codeblock outputclass="language-sql"><![CDATA[CASE hist.result WHEN "won" THEN 1 ELSE 0 END]]></codeblock>

<codeblock outputclass="language-java"><![CDATA[//import static com.couchbase.client.java.query.dsl.Expression.*;
//import static com.couchbase.client.java.query.dsl.functions.Case.*;

caseSimple(x("hist.result"))
    .when(s("won")).then(x(1))
    .elseReturn(x(0))]]></codeblock>

            <p>
                Second example implements more complex scoring rule using a Search Case (first match of the day counts as 5 points if won):
            </p>

<codeblock outputclass="language-sql"><![CDATA[CASE WHEN hist.result = "won" AND hist.matchNumber = 1 THEN 5
WHEN hist.result = "won" THEN 1
WHEN hist.result = "lost" THEN 0
END]]></codeblock>

<codeblock outputclass="language-java"><![CDATA[//import static com.couchbase.client.java.query.dsl.Expression.*;
//import static com.couchbase.client.java.query.dsl.functions.Case.*;

caseSearch()
    .when(x("hist.result").eq(s("won")).and(x("hist.matchNumber").eq(1))).then(x(5))
    .when(x("hist.result").eq(s("won"))).then(x(1))
    .when(x("hist.result").eq(s("lost"))).then(x(0))
    .end(); //no ELSE clause means other values will return NULL, have to explicitly close the CASE]]></codeblock>
        </section>



        <section id="collections">
            <title>Collection Operators Mini DSL</title>
            <p>
                The <apiname>com.couchbase.client.java.query.dsl.functions.Collections</apiname> class contains a mini-DSL to deal with Collections operators in N1QL, such as <codeph>ANY</codeph>, <codeph>EVERY</codeph>, <codeph>ARRAY</codeph> and <codeph>FIRST</codeph>.
            </p>
            <p>
                For example, the <codeph>ARRAY</codeph> construct is defined as:
            </p>
<codeblock outputclass="language-sql"><![CDATA[ARRAY expression FOR variable ( IN |  WITHIN ) expression
[ ,  variable ( IN | WITHIN ) expression ]* [ ( WHEN  condition) ] END ]]></codeblock>
            <p>
                The corresponding mini-DSL is <apiname>Collections.arrayIn</apiname> (or <apiname>Collections.arrayWithin</apiname> if you want to start with a WITHIN clause).
                Let's see two examples from the following statement, which extracts children and also lists the ones that are teenagers:
            </p>
<codeblock outputclass="language-sql"><![CDATA[SELECT tutorial.fname || ' ' || tutorial.lname AS adult,
    ARRAY child FOR child IN tutorial.children END AS children,
    ARRAY child.fname FOR child IN tutorial.children WHEN child.age >= 12 END AS teenagers
FROM tutorial WHERE tutorial.children IS NOT NULL;]]></codeblock>
            <p>
                Here is how to write the second and third lines using the DSL:
            </p>

<codeblock outputclass="language-java"><![CDATA[//import static com.couchbase.client.java.query.dsl.Expression.*;
//import static com.couchbase.client.java.query.dsl.functions.Collections.*;

//ARRAY child FOR child IN tutorial.children END AS children
arrayIn(x("child"), "child", path("tutorial", "children")).end().as("children");

//ARRAY child.fname FOR child IN tutorial.children WHEN child.age >= 12 END AS teenagers
arrayIn(path("child", "fname"), "child", path("tutorial", "children")).when(path("child", "age").gte(12)).as("teenagers"));]]></codeblock>

            <p>
                Similarly, <codeph>ANY</codeph> allows to test for a condition that applies to at least one member of a nested array (you can also match on <codeph>EVERY</codeph> member of the array).
                Any is defined as:
            </p>
<codeblock outputclass="language-sql"><![CDATA[ANY variable ( IN  | WITHIN ) expression
[  ,  variable ( IN | WITHIN ) expression  ]*
SATISFIES condition  END]]></codeblock>
            <p>
                In the previous example, you would see an entry for a parent that doesn't have teenagers (its "teenagers" field would be empty), because the statement didn't specify that the children should contain a teenager. You can fix that with ANY, by rewriting the WHERE clause:
            </p>
<codeblock outputclass="language-sql"><![CDATA[#...FROM tutorial
#replace "WHERE tutorial.children IS NOT NULL" with:
WHERE ANY child IN tutorial.children SATISFIES child.age >= 12;]]></codeblock>

<codeblock outputclass="language-java"><![CDATA[//import static com.couchbase.client.java.query.dsl.Expression.*;
//import static com.couchbase.client.java.query.dsl.functions.Collections.*;

anyIn("child", x("tutorial.children")).satisfies(x("child.age").gte(12))]]></codeblock>
        </section>
    </conbody>
</concept>
