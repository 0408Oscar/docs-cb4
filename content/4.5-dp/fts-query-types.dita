<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_jfq_fn4_1v">
  <title>Types of Queries</title>
  <body>
    <section><title>Simple Queries</title>
     <dl>
       <dlentry id="match-query">
         <dt>Match Query</dt>
         <dd>A match query analyzes the input text and uses that analyzed text to query the index. An attempt is made to use the same analyzer that was used when the field was indexed. <p>The match query can optionally perform fuzzy matching. If the fuzziness parameter is set to a non-zero integer the analyzed text will be matched with the specified level of fuzziness. Also, the prefix_length parameter can be used to require that the term also have the same prefix of the specified length.</p></dd>
       </dlentry>
       <dlentry id="match-phrase-query">
         <dt>Match Phrase Query</dt>
         <dd>The input text is analyzed and a phrase query is built with the terms resulting from the analysis. This type of query searches for terms occurring in the specified positions and offsets. This depends on term vectors, which are consulted to determine phrase distance. <p>Although this is not an exact match, it is usually the search behavior users want.</p> <p>For example, a match phrase query for “location for functions” might match “locate the function” if the standard en analyzer is used. This is because the stemmer tokenizes “location” and “locate” to “locati”, and “functions” and “function” to “function.” Stop word removal will remove “for” and “the” but the distance between the tokens will be the same. </p></dd>
       </dlentry>
       <dlentry>
         <dt>Fuzzy Query</dt>
         <dd>A fuzzy query is a term query that matches terms within a specified edit distance (Levenshtein distance). Also, you can optionally specify that the term must have a matching prefix of the specified length.</dd>
       </dlentry>
       <dlentry>
         <dt>Prefix Query</dt>
         <dd>The prefix query finds documents containing terms that start with the provided prefix.</dd>
       </dlentry>
       <dlentry>
         <dt>Regexp Query</dt>
         <dd>Finds documents containing terms that match the specified regular expression.</dd>
       </dlentry>
     </dl></section>
    <section><title>Compound Queries</title>
      <dl>
        <dlentry>
          <dt>Conjunction Query</dt>
          <dd>The conjunction query is a compound query. Result documents must satisfy all of the child queries.</dd>
        </dlentry>
        <dlentry>
          <dt>Disjunction Query</dt>
          <dd>The disjunction query is a compound query. Result documents must satisfy a configurable min number of child queries. By default this min is set to 1.</dd>
        </dlentry>
        <dlentry>
          <dt>Boolean Query</dt>
          <dd>The boolean query is a useful combination of conjunction and disjunction queries. A boolean query takes three lists of queries: <ul>
            <li>must - result documents must satisfy all of these queries</li>
            <li>should - result documents should satisfy these queries</li>
            <li>must not - result documents must not satisfy any of these queries</li>
          </ul></dd>
        </dlentry>
      </dl>
    </section>
    <section><title>Range Queries</title>
      <dl>
        <dlentry>
          <dt>Date Range Query</dt>
          <dd>The date range query finds documents containing a date value in the specified field within the specified range. Define the endpoints using the fields start  and end. You can omit one endpoint, but not both. The inclusiveStart and inclusiveEnd properties in the query JSON control whether or not the end points are included or excluded. </dd>
        </dlentry>
        <dlentry>
          <dt>Numeric Range Query</dt>
          <dd>The numeric range query finds documents containing a numeric value in the specified field within the specified range. Define the endpoints using the fields min  and max. You can omit one endpoint, but not both. The inclusiveMin and inclusiveMax properties control whether or not the end points are included or excluded. By default, min is inclusive and max is exclusive.</dd>
        </dlentry>
      </dl>
    </section>
    <section><title>Query String Query</title>
      <p>Also known as the String Query, the query string query allows humans to describe complex queries using a simple syntax. When you search a full text index with the Web Admin UI, you use this query syntax. </p><note>Certain queries that are supported by FTS are not yet supported by the query string syntax. This includes wildcards, regexp, and date range queries.</note>
<dl>
  <dlentry>
    <dt>Match</dt>
    <dd>A term without any other syntax is interpreted as a match query for the term in the default
            field. The default field is _all unless overridden in the <xref
              href="fts-custom-mapping.dita#topic_hfg_hh4_1v/def-field-all">index mapping</xref>.
              <p>Example: water performs a <xref href="#topic_jfq_fn4_1v/match-query" format="dita"
                >Match Query</xref> for the term water.</p></dd>
  </dlentry>
  <dlentry>
    <dt>Match Phrases</dt>
    <dd>Placing the search terms in quotes performs a match phrase query. This is not an exact match, see <xref href="#topic_jfq_fn4_1v/match-phrase-query" format="dita"
      >Match Phrases Query</xref> for more information. <p>Example: "light beer" performs a <xref href="#topic_jfq_fn4_1v/match-phrase-query" format="dita"
        >Match Phrases Query</xref> for the phrase <parmname>light beer</parmname>.</p></dd>
  </dlentry>
  <dlentry>
    <dt>Field Scoping</dt>
    <dd>You can qualify the field for these searches by prefixing them with the name of the field separated by a colon.
      <p>Example: description:water performs a Match Query [LINK] for the term water, in the description field.</p></dd>
  </dlentry>
  <dlentry>
    <dt>Required, Optional, and Exclusion</dt>
    <dd>When your query string includes multiple items, by default these are placed into the SHOULD
            clause of a <xref
              href="http://www.blevesearch.com/docs/Query/#boolean:8f767fbc41af8ff1ddcf4c60ed8c0fe9"
              format="html" scope="external">Boolean Query</xref>. <p>You can change this by prefixing your items with a + or ‘-’. * ‘+’ Prefixing with plus places that item in the MUST portion of the boolean query. * ‘-’ Prefixing with a minus places that item in the MUST NOT portion of the boolean query.</p>
      <p>Example: +description:water -light beer will perform a Boolean Query that MUST satisfy the Match Query for the term water in the description field, MUST NOT satisfy the Match Query for the term light in the default field, and SHOULD satisfy the Match Query for the term beer in the default field. Result documents satisfying the SHOULD clause will score higher than those that do not.</p></dd>
  </dlentry>
  <dlentry>
    <dt>Boosting</dt>
    <dd>You can influence the relative importance of the clauses by suffixing clauses with the ^ operator followed by a number. <p>Example: description:water name:water^5 will perform Match queries for water in both the name and description fields, but documents having the term in the name field will score higher.</p></dd>
  </dlentry>
  <dlentry>
    <dt>Numeric Ranges</dt>
    <dd>You can perform numeric ranges by using the &gt;, &gt;=, &lt;, and &lt;= operators, followed by a numeric value. <p>Example: abv:&gt;10 will perform an Numeric Range Query on the abv field for values greater than ten.</p></dd>
  </dlentry>
</dl>
    </section>
    <section><title>Queries for Debugging</title>
      <p>Term and Phrase queries do not perform any analysis on their inputs. This is useful for debugging exactly what is in an index, but this is rarely used otherwise. Typically, users want match and phrase match queries.</p> 
      <p>In the normal case, an analyzer is used on both the text to be indexed and the query terms. Because the terms in the index have usually been run through an analyzer and a stemmer, they often no longer look like normal language. End users of search systems never see the stored terms but because their queries are also run through the same analyzer, the results match.</p>
      <p>Basically, a user who is going to do a Term or Phrase search already has to know all of this when they select that type of search, because they aren’t entering normal words, they might be entering weird non-words like “natio” or “beaut" instead of queries like “National” or “beauties”</p> <dl>
        <dlentry>
          <dt>Term Query</dt>
          <dd>A term query is the simplest possible query. It performs an exact match in the index for the provided term. Most of the time users should use a Match Query instead. <p>For example, a term query for “lovingli” would match documents with the term “lovingly” if they were indexed with the “en” analyzer. A term query for the  “lovingly” won’t match any documents that were indexed with the “en” analyzer. </p></dd>
        </dlentry>
        <dlentry>
          <dt>Phrase Query</dt>
          <dd>A phrase query searches for terms occurring in the specified position and offsets. <p>The phrase query performs an exact term match for all the phrase constituents without using an analyzer. If you want the phrase to be analyzed, consider using the Match Phrase Query instead.</p></dd>
        </dlentry>
      </dl></section>
    <section><title>Simple Queries</title>
      <p></p></section>
    <section><title>Simple Queries</title>
      <p></p></section>
    <section><title>Simple Queries</title>
      <p></p></section>
  </body>
</topic>
