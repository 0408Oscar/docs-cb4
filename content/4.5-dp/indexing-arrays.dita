<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_hv4_sbr_w5">
  <title>Indexing Arrays</title>
  <body>
    <p>Couchbase 4.5 adds the capability to create global indexes on array elements and optimizes
      the execution of queries involving array elements. This is a huge leap from the previous
      versions where secondary indexes could only be created and subsequently queried on whole
      arrays. You can now create an index of array elements ranging from plain scalar values to
      complex arrays or JSON objects nested deeper in the array. </p>
    <section> <title>N1QL Syntax</title>
      <codeblock>CREATE INDEX [ <varname>index_name</varname> ] 
        ON <varname>named_keyspace_ref</varname> ( <varname>expression</varname> || <varname>all_expression</varname>, … )
        WHERE <varname>filter_expressions</varname>
        USING GSI
        [ WITH { "nodes": [ "<varname>node_name</varname>" ], 
                "defer_build": true | false
              }
        ];</codeblock>
      <p>
        <dl>
          <dlentry>
            <dt><varname>index_name</varname></dt>
            <dd>Specify a unique name to identify the index. The index name is optional and there can be one index that is unnamed.</dd>
          </dlentry>
          <dlentry>
            <dt><varname>named_keyspace_ref</varname></dt>
            <dd><codeblock><varname>named_keyspace_ref</varname> ::= [ <varname>namespace-name</varname> : ] <varname>keyspace-name</varname></codeblock> <p>Specify the name of the bucket to create an index on</p></dd>
          </dlentry>
          <dlentry>
            <dt><varname>expression</varname></dt>
            <dd>Refers to the an attribute name or a function that returns a single element.</dd>
          </dlentry>
          <dlentry>
            <dt><varname>all_expression</varname></dt>
            <dd><codeblock><varname>all_expression</varname> ::= ALL [ <varname>indexable_expression1</varname> [ , <varname>indexable_expression2,</varname> … ] IN ] <varname>source_expression</varname></codeblock>
              <p>The ALL clause ensures iteration over the <varname>source_expression</varname> array and returns one or more indexable expressions. <ul>
                <li><varname>all_expression</varname> can be a standalone expression or a compound expression with other non-ALL expressions.</li>
                <li>Only one expression in the compound indexes can use the ALL clause.</li>
                <li>If the <varname>source_expression</varname> or <varname>indexable_expression</varname> is missing, a MISSING value is returned and MISSING is not indexed.</li>
                <li>If the <varname>source_expression</varname> is not missing and <varname>source_expression</varname> is either NULL, not an array, or is an empty array, NULL is returned. NULL is indexed.</li></ul></p></dd> 
          </dlentry>
          <dlentry>
            <dt><varname>filter_expression</varname></dt>
            <dd>Specifies a predicate to qualify the subset of documents to include in the index.
              The ALL clause iterates over all the elements of the array. Consider the following
              statement which indexes all elements of '<codeph>b</codeph>' even though the
              expression filters on '<codeph>b.i</codeph>':
              <codeblock>CREATE INDEX i1 
         ON default ( ALL b ) 
         WHERE ANY i IN b SATISFIES i > 1 END;</codeblock></dd>
          </dlentry>
          <dlentry>
            <dt>USING GSI</dt>
            <dd>USING clause specifies the index type to use. When using the ALL clause, USING only
              supports GSI. <note>VIEW index type is not supported when using the ALL
              clause.</note></dd>
          </dlentry>
          <dlentry>
            <dt>WITH options</dt>
            <dd>Use the WITH clause to specify additional options and is fully supported with nodes,
                <varname>defer_build</varname>, and <varname>in_memory</varname> expressions.</dd>
          </dlentry>
        </dl> </p> </section>
    <section><title>Examples</title>
      <!--<p>Let's use the following sample document with doc Id "foo":
        <codeblock>{
        "a":1,
        "b":[1,2],
        "c":{"ca":[1,2,3], "cb":4},  
        "d":[{"da":5,"db":6},
        {"da":7,"db":8}],
        "e":[{"ea":9,"eb":[10,11,12]},
        {"ea":13,"eb":[14,NULL,16]}],
        "f":[[17,18],
        [19,20,21]]
}   </codeblock></p>-->
      <p>Consider the following sample documents: <ul id="ul_yn3_y5w_y5">
        <li>Food:
            <codeblock>"freefood_DocID" : 
          { 
          "type" :  "juice",
          "items" : ["tomato", "cranberry", "mango"] , 
          "airline_ids" : ["AI444", "AI333", "AI222"]  
          } ,    
          { 
           "type" :  "snack",
           "items" : ["peanuts", "crackers"],
           "airline_ids" : ["AI444", "UA123", "SW111"]   
          }     </codeblock></li>
        <li>Airlines_info<codeblock>"AI444_DocID":  
          {
          "id" : "AI 444", 
          "schedule" : { 
                          "source"          : "SFO",
                          "source-time" : "8:44 AM", 
                          "dest"               :  "JFK",
                          "dest-time"     : "00:04 AM" 
                        }
          }
        </codeblock></li>
        <li>Passenger_trips
            <codeblock>"John Smith_docID" :   
          {
          "Name" : "John Smith",
          "Trips"  : [ 
                      { "purpose" :  "Business",
                        "flight_segments" : [ 
                            [ { "day"    : "Jan 4, 2016", "flight" : "AA444_DocID" }, 
                              { "day"    : "Jan 4, 2016", "flight" : "AA333_DocID"} ], 
                            [ { "day"    : "Jan 10, 2016", "flight" : "XY222_DocID"} ] 
                        ]
                      }, 
                 …  ]
          }</codeblock></li>
        </ul></p>
      <p><b>Indexing individual elements in an array</b></p>
      <p>Use the ALL clause in CREATE INDEX to create an index that iterates over the individual
        elements of an array and indexes each element.
        <codeblock><!--CREATE INDEX i1 ON default(ALL b) USING GSI;-->  
CREATE INDEX fi1 ON Food (DISTINCT ARRAY i FOR i IN Food.items  END);
          
CREATE INDEX pi1 ON Passenger_trips  p (DISTINCT ARRAY t FOR t IN p.trips END) USING GSI;</codeblock></p>
     <!-- <p>Given <parmname>b</parmname> is an array consisting of the elements <parmname>[1, {"A":1,
          "B":2},[0,1,2]]</parmname>. The index <parmname>i1</parmname> contains 3 separate elements
        with 3 separate doc Ids, one for each element in the array.</p>-->
      <p>The following query takes advantage of the indices created above: <!--<codeblock>//uses each element of the index to test i=?
select * from default 
  WHERE any i in b satisfies i=1 end;

select * from default 
  WHERE every i in b satisfies i&lt;100 end;

//uses each element of the index to test t2=?
select * from default t1 UNNEST t1.b t2 
  WHERE t2={"A":1, "B":2};</codeblock>-->
        <codeblock>//Find all airlines that serve snacks or juice containing tomatoes

SELECT airline_ids FROM Food WHERE ANY i IN Food.items SATISFIES i = "tomato";</codeblock></p>
      <p><b>Compound indexing with individual elements of an array and other attributes</b></p>
      <p>Use the ALL clause when creating an index to combine non-array elements with array elements. In such cases, the ALL clause iterates over the individual elements of an array and indexes each element. For example,  <!--<codeblock>CREATE INDEX i1 ON default(ALL b, a) USING GSI; </codeblock>--> <codeblock>CREATE INDEX cfi1 ON Food (DISTINCT ARRAY {I, f.type} FOR i IN Food.items  END);</codeblock></p>
      <!--<p>Given b is [1, {"A":1, "B":2},[0,1,2]], the index (i1) leaf contains 3 separate elements (b[1],a), (b[2],a), (b[3],a) respectively and a doc Id per index element. </p>
      <codeblock>CREATE INDEX i1 ON default(a, ALL b) USING GSI;</codeblock>
      <p>Given b is [1, {"A":1, "B":2},[0,1,2]], the index (i1) leaf contains 3 separate elements (a, b[1]), (a, b[2]), (a, b[3]) respectively and a doc Id per index element. </p>-->
      <p>The following queries can take advantage of the index created above: 
        <!--<codeblock>//uses each element of the index to test i=?
select * from default 
  WHERE any i in b satisfies i=1 end AND a=1;

//uses each element of the index to test t2=?
select * from default t1 UNNEST t1.b t2 
  WHERE t2={"A":1, "B":2} and t1.a=1;
        </codeblock>--><codeblock>
//Find all airlines that serve tomato juice 
SELECT airline_ids FROM Food  WHERE  ANY i IN Food.items SATISFIES i = "tomato" AND Food.type = "juice";

//Get all food served in airlines and group by the airlineID
Select  aID, food.type  from Food where UNNEST Food.airline_id  aID  GROUP BY aID
</codeblock></p>
      <p><b>Indexing individual attributes of an array of documents</b></p>
      <p>Use the ALL clause to index specific attributes of a document when the array contains documents. For example, attribute d in the sample document "foo". In this case, when you create an index, the ALL clause iterates over the individual elements of an array and indexes each element.</p> <p>For example, <!--<codeblock>CREATE INDEX i1 ON default(ALL da, db IN d) USING GSI;</codeblock>Given d is "d":[{"da":5,"db":6, "dc":6.5},{"da":7,"db":8}], the index leaf contains 2 elements (da, db) and a docID per index element.</p>-->
        <!--<p><codeblock>CREATE INDEX i1 ON default(ALL dc IN d) USING GSI;</codeblock> Given d is "d":[{"da":5,"db":6, "dc":6.5},{"da":7,"db":8}], the index leaf contains 1 element (dc) and a docID per index element.--> <codeblock>CREATE INDEX pi2 ON Passenger_trips p (DISTINCT ARRAY t.purpose FOR t IN p.trips END) USING GSI  </codeblock></p>
      <p>The following queries can take advantage of the index created above:
        <!--<codeblock>//uses each element of the index to test i=?
select * from default 
  WHERE every i IN d satisfies i.da>=5 end;

select * from default 
  WHERE any i IN d satisfies i.dc=5 AND i.db=6 end;</codeblock>--> <codeblock>//Find all passenger names who made business trips
Select  name  FROM Passenger_trips  p   where  ANY t in p.trips  satisfies t.purpose = "Business" </codeblock></p>
      <p><b>Indexing the individual elements of nest arrays</b></p>
      <p>Use the ALL clause to index specific attributes of a document when the array contains other arrays or documents that contain arrays. <!--For example, attribute f and e in the sample document "foo".--> In this case, when you create an index, the ALL clause iterates over the individual elements of the outer array. Use a nested ALL clause to iterate on additional arrays.</p> 
      <p>For example, <!--<codeblock>CREATE INDEX i1 ON default(e[].{ea,eb[].{ebb, ebc}}) USING GSI;</codeblock> Given d as "e":[{"ea":9,"eb":[10,11,12]},{"ea":13,"eb":[14,NULL,16]}] the index leaf contains 6 elements (ea, eb) and a docID per index element.-->
        <codeblock> CREATE INDEX  na1 from Passenger_trips p 
        ( DISTINCT ARRAY 
                  ( DISTINCT ARRAY leg.flight  FOR leg IN s END ) 
                    FOR s IN flight_segments  END ); </codeblock></p>
      <!--<p><codeblock>CREATE INDEX i1 ON default(ALL (ALL f)) USING GSI;</codeblock> Given d as "f":[[17,18],[19,20,21]] the index leaf contains 5 elements (f..) and a docID per index element.</p>-->
      <p>The following query takes advantage of the index created above:
        <codeblock>SELECT * FROM Passenger_Trips p 
          WHERE ANY leg IN s SATISFIES day(leg.flight) = "AI444" END 
          UNNEST p.flight_segments  s;</codeblock></p>
    </section>
    <section id="array-idx-limitations"><title>Limitations</title>
      <p> Let's use the following sample document with Doc_Id "foo" to explain the limitations:
        <codeblock>"foo": {
          "a":1,
          "b":[1,2],
          "c":{"ca":[1,2,3], "cb":4},  
          "d":[{"da":5,"db":6},
          {"da":7,"db":8}],
          "e":[{"ea":9,"eb":[10,11,12]},
          {"ea":13,"eb":[14,NULL,16]}],
          "f":[[17,18],
          [19,20,21]]
          }   </codeblock><ul>
        <li>Covering indexes with indexed arrays do not cover queries where the array needs to be
            reconstructed in full form, with duplicates and position of each element placed
            correctly in the projection. <table frame="all" rowsep="1" colsep="1"
              id="table_crm_35r_w5">
              <tgroup cols="2">
                <colspec colname="c1" colnum="1" colwidth="1*"/>
                <colspec colname="c2" colnum="2" colwidth="7.33*"/>
                <thead>
                  <row>
                    <entry>Supported</entry>
                    <entry>Example</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry><image href="pict/yes-check.png" width="32" height="32"
                        id="image_mq3_1wr_w5" align="center"/></entry>
                    <entry><codeblock>SELECT a 
         FROM default 
         WHERE ANY i IN b SATISFIES i &lt; 5 END;</codeblock></entry>
                  </row>
                  <row>
                    <entry><image href="pict/yes-check.png" width="32" height="32"
                      id="image_p2j_cwr_w5" align="center"/></entry>
                    <entry><codeblock>SELECT ARRAY_DISTINCT(b) 
        FROM default 
        WHERE a = 5;</codeblock></entry>
                  </row>
                  <row>
                    <entry><image href="pict/neg-check.png" width="32" height="32"
                      id="image_phk_dwr_w5" align="center"/></entry>
                    <entry> <codeblock>SELECT b,a 
       FROM default;</codeblock></entry>
                  </row>
                </tbody>
              </tgroup>
            </table></li>
        <li>Indexed arrays do not maintain duplicate elements of an array or the position of the
            elements within an array in the GSI array index. This means that GSI array indexes do
            not cover expressions that reference the array attribute itself. For example, the
            following statements are not
            supported:<codeblock>SELECT b FROM default;
SELECT b[*] FROM default;
SELECT b[1] FROM default;</codeblock></li>
        <li>N1QL WITHIN is not supported with the ALL keyword. WITHIN requires a full iteration of the complete sub-tree while the ALL keyword explicitly unpacks a single specific level of a tree.  </li>
        
      </ul></p>
    </section>
  </body>
</topic>
