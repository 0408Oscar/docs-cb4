<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_hv4_sbr_w5">
  <title>Array Indexing</title>
  <body>
    <p>Couchbase 4.5 adds the capability to create global indexes on array elements and optimizes
      the execution of queries involving array elements. This is a huge leap from the previous
      versions where secondary indexes could only be created and subsequently queried on whole
      arrays. You can now create an index of array elements ranging from plain scalar values to
      complex arrays or JSON objects nested deeper in the array. </p>
    <section> <title>N1QL Syntax</title>
      <codeblock>CREATE INDEX [ <varname>index_name</varname> ] 
        ON <varname>named_keyspace_ref</varname> ( <varname>expression</varname> || <varname>distinct_array_expression</varname>, â€¦ )
        [ WHERE <varname>filter_expressions</varname> ]
        [ USING GSI ]
        [ WITH { "nodes": [ "<varname>node_name</varname>" ], 
                "defer_build": true | false
              }
        ];</codeblock>
      <p>
        <dl>
          <dlentry>
            <dt><varname>index_name</varname></dt>
            <dd>Specify a unique name to identify the index. The index name is optional and there can be one index that is unnamed.</dd>
          </dlentry>
          <dlentry>
            <dt><varname>named_keyspace_ref</varname></dt>
            <dd><codeblock><varname>named_keyspace_ref</varname> ::= [ <varname>namespace-name</varname> : ] <varname>keyspace-name</varname></codeblock> <p>Specify the name of the keyspace or bucket to create an index on</p></dd>
          </dlentry>
          <dlentry>
            <dt><varname>expression</varname></dt>
            <dd>Refers to the an attribute name or a function (or expression) that returns a single
              element.</dd>
          </dlentry>
          <dlentry>
            <dt><varname>distinct_array_expression</varname></dt>
            <dd><codeblock><varname>distinct_array_expression</varname> ::= 
[ ALL ] DISTINCT ARRAY <varname>expression</varname> FOR <varname>variable1</varname> ( IN | WITHIN ) <varname>expression1</varname>
                                      [ , <varname>variable2</varname> ( IN | WITHIN ) <varname>expression2</varname> ]
                                      [ ( WHEN <varname>condition</varname> ) ] END</codeblock>
              <p>The <cmdname>ARRAY</cmdname> operator lets you map and filter the elements or
                attributes of a collection, object, or objects. It evaluates to an array of the
                operand expression that satisfies the WHEN clause, if specified.</p></dd> 
          </dlentry>
          <dlentry>
            <dt><varname>filter_expression</varname></dt>
            <dd>Specifies WHERE clause predicates to qualify the subset of documents to include in
              the index. </dd>
          </dlentry>
          <dlentry>
            <dt>USING GSI</dt>
            <dd>USING clause specifies the index type to use. </dd>
          </dlentry>
          <dlentry>
            <dt>WITH options</dt>
            <dd>Use the WITH clause to specify additional options and is fully supported with nodes
              and <varname>defer_build</varname> expressions.</dd>
          </dlentry>
        </dl> </p><p>See the <xref
          href="http://developer.couchbase.com/documentation/server/4.1/n1ql/n1ql-language-reference/createindex.html"
          format="html" scope="external">CREATE INDEX</xref> statement for more details on the
        syntax. </p> </section>
    <section><title>Examples</title>
      <p>The following samples use the <codeph>travel-sample</codeph> bucket. </p>
      <p><b>Indexing individual elements in an array</b></p>
      <p>Create an index on all schedules:
        <codeblock>CREATE INDEX isched 
        ON `travel-sample` ( DISTINCT ARRAY v FOR v IN schedule END );</codeblock></p>
      <p><b>Indexing individual attributes of an array of documents</b></p>
      <p>Create an index on flight IDs scheduled in the first 4 days of the week:
        <codeblock>CREATE INDEX iflight_day 
       ON `travel-sample` ( DISTINCT ARRAY v.flight FOR v IN schedule WHEN v.day &lt; 4 END )
       WHERE type = "route" ;</codeblock></p>
      <p><b>Compound indexing with individual elements of an array and other attributes</b></p>
      <p>Create an index on scheduled flight IDs and number of stops:
        <codeblock>CREATE INDEX iflight_stops 
       ON `travel-sample` ( stops, DISTINCT ARRAY v.flight FOR v IN schedule END )
       WHERE type = "route" ;</codeblock></p>
      <p>The following query finds the list of scheduled flights grouped by the number of stops:
        <codeblock>SELECT stops, ( DISTINCT ARRAY v.flight FOR v IN schedule end) FROM `travel-sample` 
        WHERE type = "route" AND stops >= 0 GROUP BY stops; 
      
{
    "requestID": "32af49be-5163-4460-b696-7ca328c91077",
    "signature": {
        "$1": "array",
        "stops": "json"
    },
    "results" : [
        {
             "$1": [
                  "2L372",
                  "2L037",
                  "2L086",
                  "2L379",
                  "2L622",
                  "2L335",
                  "2L537",
                  "2L160",
                  "2L431",
                  "2L948",
                  "2L259",
                  "2L566",
                  "2L156",
                  "2L033",
                  "2L000",
                  "2L813",
                  "2L599",
                  "2L793",
                  "2L006",
                  "2L975",
                  "2L470",
                  "2L687"
             ],
             "stops": 0
         }, 
         {
             "$1": [
                 "FL692",
                 "FL925",
                 "FL798",
                 "FL743",
                 "FL380",
                 "FL023",
                 "FL515",
                 "FL924",
                 "FL403",
                 "FL711",
                 "FL870",
                 "FL926",
                 "FL514",
                 "FL570",
                 "FL316",
                 "FL825",
                 "FL156"
            ],
            "stops": 1
        }
    ],
    "status": "success",
    "metrics": {
        "elapsedTime": "26.227097179s",
        "executionTime": "26.227073598s",
        "resultCount": 2,
        "resultSize": 1111
    }
}     </codeblock></p>
      
      
      <p><b>Indexing the individual elements of nest arrays</b></p>
      <p>Use the DISTINCT ARRAY clause in a nested fashion to index specific attributes of a
        document when the array contains other arrays or documents that contain arrays. For example, <codeblock>cbq> UPDATE `travel-sample` 
SET schedule[0] = {"day" : 7, "special_flights" : 
                    [ {"flight" : "AI444", "utc" : "4:44:44"}, 
                      {"flight" : "AI333", "utc" : "3:33:33" } 
                    ] } 
WHERE type = "route" AND destinationairport = "CDG" AND sourceairport = "TLV";</codeblock>
        <codeblock>cbq> CREATE INDEX inested ON `travel-sample`
( DISTINCT ARRAY (DISTINCT ARRAY y FOR y IN x.special_flights END) FOR x IN schedule END) 
WHERE type = "route";</codeblock></p>
    </section>
    <section id="array-idx-limitations"><title>Limitations</title>
      <p> Let's use the following sample document with Doc_Id "foo" to explain the limitations:
        <codeblock>"foo": {
          "a":1,
          "b":[1,2],
          "c":{"ca":[1,2,3], "cb":4},  
          "d":[{"da":5,"db":6},
          {"da":7,"db":8}],
          "e":[{"ea":9,"eb":[10,11,12]},
          {"ea":13,"eb":[14,NULL,16]}],
          "f":[[17,18],
          [19,20,21]]
          }   </codeblock><ul>
        <li>Covering indexes with indexed arrays do not cover queries where the array needs to be
            reconstructed in full form, with duplicates and position of each element placed
            correctly in the projection. <table frame="all" rowsep="1" colsep="1"
              id="table_crm_35r_w5">
              <tgroup cols="2">
                <colspec colname="c1" colnum="1" colwidth="1*"/>
                <colspec colname="c2" colnum="2" colwidth="7.33*"/>
                <thead>
                  <row>
                    <entry>Supported</entry>
                    <entry>Example</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry><image href="pict/yes-check.png" width="32" height="32" id="image_mq3_1wr_w5" align="center"
                        placement="break"/></entry>
                    <entry><codeblock>SELECT a 
         FROM default 
         WHERE ANY i IN b SATISFIES i &lt; 5 END;</codeblock></entry>
                  </row>
                  <row>
                    <entry><image href="pict/yes-check.png" width="32" height="32" id="image_p2j_cwr_w5" align="center"
                        placement="break"/></entry>
                    <entry><codeblock>SELECT ARRAY_DISTINCT(b) 
        FROM default 
        WHERE a = 5;</codeblock></entry>
                  </row>
                  <row>
                    <entry><image href="pict/neg-check.png" width="32" height="32" id="image_phk_dwr_w5" align="center"
                        placement="break"/></entry>
                    <entry> <codeblock>SELECT b,a 
       FROM default;</codeblock></entry>
                  </row>
                </tbody>
              </tgroup>
            </table></li>
        <li>Indexed arrays do not maintain duplicate elements of an array or the position of the
            elements within an array in the GSI array index. This means that GSI array indexes do
            not cover expressions that reference the array attribute itself. For example, the
            following statements are not
            supported:<codeblock>SELECT b FROM default;
SELECT b[*] FROM default;
SELECT b[1] FROM default;</codeblock></li>
        <li>Array indexes only support ARRAY, DISTINCT, IN, and WITHIN operators. All other
            operators such as ALL and EVERY are not supported.  </li>
        
      </ul></p>
    </section>
  </body>
</topic>
