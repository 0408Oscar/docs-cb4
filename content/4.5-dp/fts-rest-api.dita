<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_ytp_sx4_1v">
  <title>REST API Reference</title>
  <body>
    <note>The REST APIs for FTS are provisional in Developer Preview. Any aspect may change significantly in the future up until GA.</note>
    <p>For Full Text Search, the REST endpoints below can be reached on port 9110. If running in a multi-node environment, you have to connect to a node with Full Text service enabled.</p>
    <section><title>Indexing</title>
      <p><b>Index Defintion</b>
        <table frame="all" rowsep="1" colsep="1" id="table_z1d_3dp_4v">
          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <colspec colname="c3" colnum="3" colwidth="2.5*"/>
            <colspec colname="c4" colnum="4" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>HTTP Method</entry>
                <entry>URI Path</entry>
                <entry>Description</entry>
                <entry>Permission</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/index</filepath></entry>
                <entry>Returns all index definitions as JSON.</entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!read</entry>
              </row>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/index/{indexName}</filepath></entry>
                <entry>Returns the definition of an index as JSON.<p><b>param</b>: <parmname>indexName</parmname>: required, string, URL path parameter</p><p>The name of the index definition to be retrieved.</p></entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!read</entry>
              </row>
              <row>
                <entry>PUT</entry>
                <entry><filepath>/api/index/{indexName}</filepath></entry>
                <entry>Creates/updates an index definition. <p><b>param</b>:
                      <parmname>indexName</parmname>: required, string, URL path parameter</p><p>The
                    name of the to-be-created or updated index definition,validated with the regular
                    expression of ^[A-Za-z][0-9A-Za-z_\-]*$.</p><p><b>param</b>:
                      <parmname>indexParams</parmname>: optional (depends on the value of the indexType), string (JSON), form parameter</p>
                  <p><b>param</b>: <parmname>indexType</parmname>: required, string, form parameter</p>
                  <p>Supported indexType's: <ul>
                    <li>alias: an alias provides a naming level of indirection to one or more actual, target indexes.</li>
                    <li>blackhole: a blackhole index ignores all data and is not queryable; used for testing.</li>
                    <li>bleve: a full-text index powered by the bleve engine.</li>
                  </ul></p>
                  <p><b>param</b>: <parmname>planParams</parmname>: optional, string (JSON), form parameter.</p>
                  <p><b>param</b>: <parmname>prevIndexUUID</parmname>: optional, string, form parameter.</p>
                  <p>Intended for clients that want to check that they are not overwriting the index definition updates of concurrent clients.</p>
                  <p><b>param</b>: <parmname>sourceName</parmname>: optional, string, form parameter.</p>
                  <p><b>param</b>: <parmname>sourceParams</parmname>: optional (depends on the value of the sourceType), string (JSON), form parameter.</p>
                  <p><b>param</b>: <parmname>sourceUUID</parmname>:  optional, string, form parameter.</p>
                  <p><b>result on error</b>: Non-200 HTTP error code.</p>
                  <p><b>result on success</b>: HTTP 200 with body JSON of {"status": "ok"}.</p>
                  </entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!write</entry>
              </row>
              <row>
                <entry>DELETE</entry>
                <entry><filepath>/api/index/{indexName}</filepath></entry>
                <entry>Deletes an index definition. <p><b>param</b>: <parmname>indexName</parmname>: required, string, URL path parameter</p><p>The name of the index definition to be deleted.</p></entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!write</entry>
              </row>
              </tbody>
            </tgroup>
          </table>
        </p>
      <p><b>Index Management</b>
        <table frame="all" rowsep="1" colsep="1" id="table_z1d_3dp_8v">
          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <colspec colname="c3" colnum="3" colwidth="2.5*"/>
            <colspec colname="c4" colnum="4" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>HTTP Method</entry>
                <entry>URI Path</entry>
                <entry>Description</entry>
                <entry>Permission</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>POST</entry>
                <entry><filepath>/api/index/{indexName}/ingestControl/{op}</filepath></entry>
                <entry>Pause index updates and maintenance (no more ingesting document mutations). 
                  <p><b>param</b>: <parmname>op</parmname>: required, string, URL path parameter</p>
                  <p>Allowed values for op are "pause" or "resume".</p>
                </entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!manage</entry>
              </row>
              <row>
                <entry>POST</entry>
                <entry><filepath>/api/index/{indexName}/planFreezeControl/{op}</filepath></entry>
                <entry>Freeze the assignment of index partitions to nodes. <p><b>param</b>: <parmname>indexName</parmname>: required, string, URL path parameter</p><p>The name of the index whose control values will be modified.</p>
                  <p><b>param</b>: <parmname>op</parmname>: required, string, URL path parameter</p>
                  <p>Allowed values for op are "freeze" or "unfreeze".</p>
                </entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!manage</entry>
              </row>
              <row>
                <entry>POST</entry>
                <entry><filepath>/api/index/{indexName}/queryControl/{op}</filepath></entry>
                <entry>Disallow queries on an index. <p><b>param</b>: <parmname>indexName</parmname>: required, string, URL path parameter</p><p>The name of the index whose control values will be modified.</p>
                  <p><b>param</b>: <parmname>op</parmname>: required, string, URL path parameter</p>
                  <p>Allowed values for op are "allow" or "disallow".</p>
                </entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!manage</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </p>
      <p><b>Index Monitoring</b>
        <table frame="all" rowsep="1" colsep="1" id="table_z1d_3dp_9v">
          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <colspec colname="c3" colnum="3" colwidth="2.5*"/>
            <colspec colname="c4" colnum="4" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>HTTP Method</entry>
                <entry>URI Path</entry>
                <entry>Description</entry>
                <entry>Permission</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/stats</filepath></entry>
                <entry>Returns indexing and data related metrics, timings and counters from the node as JSON.</entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].stats!read</entry>
              </row>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/stats/index/{indexName}</filepath></entry>
                <entry>Returns metrics, timings and counters for a single index from the node as JSON.</entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].stats!read</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </p>
      <p><b>Index Querying</b>
        <table frame="all" rowsep="1" colsep="1" id="table_z1d_3dp_1v1">
          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <colspec colname="c3" colnum="3" colwidth="2.5*"/>
            <colspec colname="c4" colnum="4" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>HTTP Method</entry>
                <entry>URI Path</entry>
                <entry>Description</entry>
                <entry>Permission</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/index/{indexName}/count</filepath></entry>
                <entry>Returns the count of indexed documents. <p><b>param</b>:
                      <parmname>indexName</parmname>: Required, string, URL path
                  parameter</p></entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!read</entry>
              </row>
              <row>
                <entry>POST</entry>
                <entry><filepath>/api/index/{indexName}/query</filepath></entry>
                <entry>Queries an index. <p><b>param</b>: <parmname>indexName</parmname>: required,
                    string, URL path parameter</p><p>The request's POST body depends on the index
                    type. See <xref href="#topic_ytp_sx4_1v/post-index-query-details" format="dita"
                      >below</xref> for more information.</p></entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!read</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </p>
      <p id="post-index-query-details"> <b>More Information about POST <filepath>/api/index/{indexName}/query</filepath></b></p>
      <p>The request's POST body depends on the index type. For index type bleve, a simple bleve
        query POST body:
        <codeblock>{
        "query": {
            "query": "a sample query",
            "boost": 1
        },
        "size": 10,
        "from": 0,
        "highlight": null,
        "fields": null,
        "facets": null,
        "explain": false
 }
        </codeblock></p> <p>An example POST body using from/size for results paging, using ctl for a timeout and for
        "at_plus" consistency level. On consistency, the index must have incorporated at least
        mutation sequence-number 123 for partition (vbucket) 0 and mutation sequence-number 234 for
        partition (vbucket) 1 (where vbucket 1 should have a vbucketUUID of a0b1c2):
        <codeblock>{
          "ctl": {
            "timeout": 10000,
            "consistency": {
              "level": "at_plus",
              "vectors": {
                "customerIndex": {
                  "0": 123,
                  "1/a0b1c2": 234
                }
              }
            }
          },
          "query": {
            "query": "alice smith",
            "boost": 1
          },
          "size": 10,
          "from": 20,
          "highlight": {
            "style": null,
            "fields": null
          },
          "fields": [
            "*"
          ],
          "facets": null,
          "explain": true
}</codeblock></p>
    </section>
    <section><title>Node</title>
      <p><b>Node Configuration</b>
        <table frame="all" rowsep="1" colsep="1" id="table_z1d_3dp_7v">
          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <colspec colname="c3" colnum="3" colwidth="2.5*"/>
            <colspec colname="c4" colnum="4" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>HTTP Method</entry>
                <entry>URI Path</entry>
                <entry>Description</entry>
                <entry>Permission</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/cfg</filepath></entry>
                <entry>Returns the node's current view of the cluster's configuration as JSON.</entry>
                <entry>cluster.settings!read</entry>
              </row>
              <row>
                <entry>POST</entry>
                <entry><filepath>/api/cfgRefresh</filepath></entry>
                <entry>Requests the node to refresh its configuration from the configuration provider.</entry>
                <entry>cluster.settings!write</entry>
              </row>
              <row>
                <entry>POST</entry>
                <entry><filepath>/api/managerKick</filepath></entry>
                <entry>Forces the node to replan resource assignments (by running the planner, if enabled) and to update its runtime state to reflect the latest plan (by running the janitor, if enabled).</entry>
                <entry>cluster.settings!write</entry>
              </row>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/managerMeta</filepath></entry>
                <entry>Returns information on the node's capabilities, including available indexing and storage options as JSON, and is intended to help management tools and web UI's to be more dynamically metadata driven.</entry>
                <entry>cluster.settings!read</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </p>
      <p><b>Node Diagnostics</b>
        <table frame="all" rowsep="1" colsep="1" id="table_z1d_3dp_6v">
          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <colspec colname="c3" colnum="3" colwidth="2.5*"/>
            <colspec colname="c4" colnum="4" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>HTTP Method</entry>
                <entry>URI Path</entry>
                <entry>Description</entry>
                <entry>Permission</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/diag</filepath></entry>
                <entry>Returns the full set of diagnostic information from the node in one shot as
                  JSON. That is, the /api/diag response will be the union of the responses from the
                  other REST API diagnostic and monitoring endpoints from the node, and is intended
                  to make production support easier. <p>For example, for a three node cluster, you
                    could capture the /api/diag output of each node with something like:
                      </p><p><codeph>curl http://cbft-01:9110/api/diag >
                      cbft-01.json</codeph></p><p><codeph>curl http://cbft-02:9110/api/diag >
                      cbft-02.json</codeph></p><p><codeph>curl http://cbft-03:9110/api/diag >
                      cbft-03.json</codeph></p><p> The /api/diag response JSON object can be quite
                    large, from 100's of KB to much more.</p><p>The motivation for /api/diag is to
                    simplify working with the Couchbase community, forums, technical support and
                    other engineers by making data capture from each FTS node a single
                  step.</p></entry>
                <entry>cluster.logs!read</entry>
              </row>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/log</filepath></entry>
                <entry>Returns recent log messages and key events for the node as JSON.</entry>
                <entry>cluster.logs!read</entry>
              </row>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/runtime</filepath></entry>
                <entry>Returns information on the node's software, such as version strings and slow-changing runtime settings as JSON.</entry>
                <entry>cluster.settings!read</entry>
              </row>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/runtime/args</filepath></entry>
                <entry>Returns information on the node's command-line, parameters, environment variables and O/S process values as JSON.</entry>
                <entry>cluster.settings!read</entry>
              </row>
              <row>
                <entry>POST</entry>
                <entry><filepath>/api/runtime/profile/cpu</filepath></entry>
                <entry>Requests the node to capture local cpu usage profiling information.</entry>
                <entry>cluster.admin</entry>
              </row>
              <row>
                <entry>POST</entry>
                <entry><filepath>/api/runtime/profile/memory</filepath></entry>
                <entry>Requests the node to capture lcoal memory usage profiling information.</entry>
                <entry>cluster.admin</entry>
              </row>
              <row>
                <entry>GET</entry>
                <entry>/api/pindex</entry>
                <entry>Get information about an index partition.</entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!read</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </p>
      <p><b>Node Management</b>
        <table frame="all" rowsep="1" colsep="1" id="table_z1d_3dp_5v">
          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <colspec colname="c3" colnum="3" colwidth="2.5*"/>
            <colspec colname="c4" colnum="4" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>HTTP Method</entry>
                <entry>URI Path</entry>
                <entry>Description</entry>
                <entry>Permission</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>POST</entry>
                <entry><filepath>/api/runtime/gc</filepath></entry>
                <entry>Requests the node to perform a GC.</entry>
                <entry>cluster.admin</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </p>
      <p><b>Node Monitoring</b>
        <table frame="all" rowsep="1" colsep="1" id="table_z1d_3dp_3v">
          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <colspec colname="c3" colnum="3" colwidth="2.5*"/>
            <colspec colname="c4" colnum="4" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>HTTP Method</entry>
                <entry>URI Path</entry>
                <entry>Description</entry>
                <entry>Permission</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/runtime/stats</filepath></entry>
                <entry>Returns information on the node's low-level runtime stats as JSON.</entry>
                <entry></entry>
              </row>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/runtime/statsMem</filepath></entry>
                <entry>Returns information on the node's low-level GC and memory related runtime stats as JSON.</entry>
                <entry></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </p>
    </section>
    <section><title>Advanced</title>
      <p><b>Index Partition Defintion</b>
        <table frame="all" rowsep="1" colsep="1" id="table_z1d_3dp_1v">
          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <colspec colname="c3" colnum="3" colwidth="2.5*"/>
            <colspec colname="c4" colnum="4" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>HTTP Method</entry>
                <entry>URI Path</entry>
                <entry>Description</entry>
                <entry>Permission</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/pindex</filepath></entry>
                <entry>Get information about an index partition.</entry>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!read</entry>
              </row>
              <row>
                <entry>GET</entry>
                <entry><filepath>/api/pindex/{pindexName}</filepath></entry>
                <entry/>
                <entry>cluster.bucket[<varname>bucket_name</varname>].fts!read</entry>
              </row>
            </tbody>
          </tgroup>
        </table></p>
      <p><b>Index Partition Querying</b><table frame="all" rowsep="1" colsep="1" id="table_z1d_3dp_2v">
        <tgroup cols="4">
          <colspec colname="c1" colnum="1" colwidth="1.0*"/>
          <colspec colname="c2" colnum="2" colwidth="1.0*"/>
          <colspec colname="c3" colnum="3" colwidth="2.5*"/>
          <colspec colname="c4" colnum="4" colwidth="1.0*"/>
          <thead>
            <row>
              <entry>HTTP Method</entry>
              <entry>URI Path</entry>
              <entry>Description</entry>
              <entry>Permission</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>GET </entry>
              <entry>/api/pindex/{pindexName}/count</entry>
              <entry/>
              <entry>cluster.bucket[<varname>bucket_name</varname>].fts!read</entry>
            </row>
            <row>
              <entry>POST</entry>
              <entry><filepath>/api/pindex/{pindexName}/query</filepath></entry>
              <entry/>
              <entry>cluster.bucket[<varname>bucket_name</varname>].fts!read</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      </p>
    </section>
  </body>
</topic>
