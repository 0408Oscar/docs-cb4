<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_ffr_mth_t5">
  <title>Sub-document API</title>
  <body>
    <p>The sub-document API enables developers to access and operate on parts of a JSON document. You no longer need to retrieve an entire document to inspect or modify a field. This improves the performance and brings better efficiency to the network IO path, especially when working with large documents. </p>
    <p>The existing key-value APIs operate only on entire documents. This means that inspecting a single field requires the entire document to be retrieved over the network. Modifying a single field involves retrieving the entire document over network, modifying the field locally, and then updating the entire locally modified document.  While key-value APIs are well suited for binary values and trivially small JSON documents, this can become a challenge when working with larger JSON documents. </p>
    <p>With the addition of sub-document API, you can now access and operate on individual JSON
      components, <term>sub-document</term>, within a larger JSON document. For example, consider
      the following JSON document with Doc Id "foo":
      <codeblock>       
       {
            name: {
                "first": John,
                "last": Smith
            },
            ssn: 12345678,
            email: jsmith@abc.com,
            …
        }
       </codeblock>
      You can retrieve John's last name using the following:
      <codeblock>SUBDOC_GET("foo", "name.last")</codeblock> Note that only the requested or modified
      fields are sent over the network as opposed to sending the entire document over network when
      using key-value APIs.</p>
    <p>Consider a simple <filepath>HelloWorld.java</filepath> example that uses the sub-document API
      to connect to the <parmname>travel-sample</parmname> bucket, fetch the
        <parmname>name</parmname> field from the document “<userinput>airline_13633</userinput>”,
      and then print it.
      <codeblock spectitle="HelloWorld.java">
import com.couchbase.client.java.Bucket;
import com.couchbase.client.java.Cluster;
import com.couchbase.client.java.CouchbaseCluster;
import com.couchbase.client.java.document.subdoc.DocumentFragment;

public class HelloWorld {

    // Fetch and print the name from an airline
    public static void main(String... args) {
        Cluster cluster = CouchbaseCluster.create("127.0.0.1");
        Bucket bucket = cluster.openBucket("travel-sample");

        DocumentFragment&lt;String> fragment = bucket.getIn("airline_13633", "name", String.class);
        System.out.println("The name is: " + fragment.fragment());
    }
}</codeblock></p>
    <p>When using key-value APIs, updates to a single field requires CAS to maintain consistency. In
      case of highly contended documents, if a CAS mismatch occurs the operation needs to be
      restarted even though the modified field remains the same. Sub-document APIs do not require
      the use of CAS when updating single fields. However, you can still use the CAS protection for
      the document if your application requires it. <note>Need more info here...</note></p>
    <p>The API uses <xref
        href="http://developer.couchbase.com/documentation/server/4.1/n1ql/n1ql-intro/queriesandresults.html"
        format="html" scope="external">N1QL's path syntax</xref> to refer to individual fields in a document. It uses the dot notation syntax to identify the logical location of an attribute within a document. In the example above, the path to the last name field is "<filepath>name.last</filepath>". </p>
    <p>Updates to a field are atomic and do not collide with updates to a different field on the
      same key. For example, the following operations do not collide although they are updating the
      same
      document.<codeblock>[Thread 1]
        cb.upsert_in(Path("foo", "name.last"), "Lennon")
[Thread 2]
        cb.upsert_in(Path("foo", "email"), "jlennon@abc.com")</codeblock></p>
    
    <p><b>Operations</b></p>
      <p>In addition to retrieving and setting fields, the sub document API allows true "append" and "prepend" operations on arrays, as well as increment and decrement operations on numeric values.</p>
    <!--<section><title>Multi-path operations</title>
      <p>Sub-document API also supports operating on multiple paths in a single key with potentially
        different commands. For the example document above, you can look up John's last name and
        email in one operation as:
        <codeblock>MULTI_LOOKUP("foo",
        [ GET("name.last"),
          GET("email")
          ]
        )  </codeblock></p></section>
    <p>Use the following syntax to retrieve multiple fields from a single
      key:<codeblock>MULTI_LOOKUP(key, [{command, path}, {command, path}…])</codeblock></p>
      <p> The multi-path operations can retrieve multiple disjoint fields from a single key
      atomically.</p>
    <p>Use the following syntax to modify multiple fields from a single key:</p>
    <codeblock>MULTI_MUTATE(key, [{command, path, value}, {command, path, value}...]</codeblock>
    <p>The multi-path operations can modify multiple disjoint fields from a single key
      atomically.</p>
    <note type="important">A multi-path operation can only perform a retrieval or a mutation, not both.</note>-->
    <p>Here is a simple example using <xref
        href="http://developer.couchbase.com/documentation/server/4.1/sdks/java-2.2/release-notes.html"
        format="html" scope="external">Java SDK 2.2.4</xref>.
      <note type="important">Sub-document API is an experimental feature in Java SDK and is intended for development purposes only. The experimental feature can have some rough edges and bugs, and may change significantly before the final GA release. This feature is <b>not supported</b> in production.</note><codeblock>// Connect to bucket and prepare a large JSON document
Cluster cluster = CouchbaseCluster.create();
Bucket bucket = cluster.openBucket();
      
JsonArray array1 = JsonArray.from("string1", 2, true);
JsonArray array2 = JsonArray.from("apple", "banana", "ananas");
      
JsonObject sub = JsonObject.create()
      .put("fruits", array2)
      .put("fruitCount", array2.size());
      
JsonArray junk = JsonArray.create();
for (int i = 0; i &lt; 1000; i++) {
      junk.add("This is a long sentence that serves no purpose whatsoever other than" +
      " making the document slightly larger. It has been repeated so far " +
      i + " times, which is a lot. Unless the number before was under 10, which isn't a lot");
}
      
JsonObject largeObject = JsonObject.create()
      .put("array", array1)
      .put("sub", sub)
      .put("someString", "this is a String")
      .put("junk", junk);
      
// Store the document, check what is stored
String key = "subdocExample";
bucket.upsert(JsonDocument.create(key, largeObject));
System.out.println("Keys in document: " + bucket.get(key).content().toMap().keySet());
      
// Get just the fruits array
DocumentFragment&lt;JsonArray&gt; fruitFragment = bucket.getIn(key, "sub.fruits", JsonArray.class);
System.out.println("Getting the sub.fruits fragment: " + fruitFragment.fragment());
/* prints
Keys in document: [sub, junk, someString, array]
Getting the sub.fruits fragment: ["apple","banana","ananas"]
*/
        
// Mutate parts of the document (fruit "ananas" should be "pineapple", remove the "junk" entry)
bucket.replaceIn(DocumentFragment.create(key, "sub.fruits[2]", "pineapple"), PersistTo.NONE, ReplicateTo.NONE);
bucket.removeIn(DocumentFragment.create(key, "junk", null), PersistTo.NONE, ReplicateTo.NONE);
        
// Get the whole document again to see what it now contains
System.out.println("Keys in document after mutations: " + bucket.get(key).content().toMap().keySet());
System.out.println("Whole document after mutations: " + bucket.get(key).content());
/*prints
Keys in document after mutations: [someString, sub, array]
Whole document after mutations: {"someString":"this is a String","sub":{"fruits":["apple","banana","pineapple"],"fruitCount":3},"array":["string1",2,true]}
*/</codeblock></p>
    <p>For information on using the sub-document API with Couchbase SDK, refer to the individual SDK
      documentation: <ul id="ul_grv_dry_y5">
        <li><xref
            href="http://developer.couchbase.com/documentation/server/4.1/sdks/java-2.2/release-notes.html"
            format="html" scope="external">Java SDK 2.2.4</xref></li>
        <li>Python SDK 2.0.8</li>
        <li>C SDK 2.5.6</li>
      </ul></p> 
    <section><title>Examples</title>
      <ul>
        <li><b>Modifying a field in a document</b><p> This example connects to the travel-sample bucket and uses the sub-document API to change the
            "callsign" field of the document "airline_13633" to "CLIPPER". It then prints the
            complete new document.
            <codeblock spectitle="MutateDict.java ">            
import com.couchbase.client.java.Bucket;
import com.couchbase.client.java.Cluster;
import com.couchbase.client.java.CouchbaseCluster;
import com.couchbase.client.java.PersistTo;
import com.couchbase.client.java.ReplicateTo;
import com.couchbase.client.java.document.subdoc.DocumentFragment;
            
public class MutateDict {
            
    // update the callsign from the pan am airline
    public static void main(String... args) {
        Cluster cluster = CouchbaseCluster.create("127.0.0.1");
        Bucket bucket = cluster.openBucket("travel-sample");
            
        // update the callsign field to CLIPPER
        DocumentFragment&lt;String$gt; fragment = DocumentFragment.create("airline_13633", "callsign", "CLIPPER");
        bucket.replaceIn(fragment, PersistTo.NONE, ReplicateTo.NONE);
              
        // Load the full document and print its content to very
        System.out.println(bucket.get("airline_13633").content());
    }
}</codeblock></p></li>
        <li><b>Manipulating arrays and dictionaries</b>
          <p>This example uses sub-document APIs to manipulate arrays and dictionaries. It connects
            to the travel-sample bucket and does the following: <ul>
              <li>Adds a new array field "fleet" to the document "airline_13633" if it does not
                already exist.</li>
              <li>Appends two elements to the "fleet" array.</li>
            </ul></p><codeblock spectitle="ArraysAndDicts.java">
import com.couchbase.client.java.Bucket;
import com.couchbase.client.java.Cluster;
import com.couchbase.client.java.CouchbaseCluster;
import com.couchbase.client.java.PersistTo;
import com.couchbase.client.java.ReplicateTo;
import com.couchbase.client.java.document.json.JsonArray;
import com.couchbase.client.java.document.json.JsonObject;
import com.couchbase.client.java.document.subdoc.DocumentFragment;
import com.couchbase.client.java.document.subdoc.ExtendDirection;
import com.couchbase.client.java.error.subdoc.PathExistsException;
          
public class ArraysAndDicts {
          
// Creates a "fleet" array and pushes aircraft into it
public static void main(String... args) {
    Cluster cluster = CouchbaseCluster.create("127.0.0.1");
    Bucket bucket = cluster.openBucket("travel-sample");
          
    // insert a fleet array if it does not exist
    DocumentFragment&lt;JsonArray&gt; fragment = DocumentFragment.create("airline_13633", "fleet", JsonArray.empty());
    try {
        bucket.insertIn(fragment, true, PersistTo.NONE, ReplicateTo.NONE);
    } catch (PathExistsException ex) {
        System.out.println("The array already exists, ignoring.");
    }
            
    // create fleet information
    DocumentFragment&lt;JsonObject&gt; aircraft1 = DocumentFragment.create("airline_13633", "fleet",
        JsonObject.create().put("name", "747-200B").put("heavy", true).put("engines", 4)
    );
              
    DocumentFragment&lt;JsonObject&gt; aircraft2 = DocumentFragment.create("airline_13633", "fleet",
        JsonObject.create().put("name", "737-200").put("engines", 2)
    );
                
    // append the aircraft information to the fleet array
    bucket.extendIn(aircraft1, ExtendDirection.BACK, false, PersistTo.NONE, ReplicateTo.NONE);
    bucket.extendIn(aircraft2, ExtendDirection.BACK, false, PersistTo.NONE, ReplicateTo.NONE);
    }
}</codeblock></li>
      </ul>
    
    </section>
    <section><title>Sub-document API Suitability</title>
      <p>The sub-document API is a trade-off in server resource usage, between CPU and network
        bandwidth. When using a sub-document command (for example, SUBDOC_DICT_ADD), the client only
        transmits the key, path and fragment to change, as opposed to sending the key, and complete
        (whole) value. Depending on the size of the document being operated on and the size of the
        fragment, this can result in a significant saving of network bandwidth. For example,
        operating on a 100KB document named "<userinput>user::j.bloggs</userinput>" where a 30 byte
        fragment is added to a path of length 20 bytes would require sending the following over the
        network: <table frame="all" rowsep="1" colsep="1" id="table_o2q_1ky_y5">
          <tgroup cols="6">
            <colspec colname="c1" colnum="1" colwidth="1.62*"/>
            <colspec colname="c2" colnum="2" colwidth="1*"/>
            <colspec colname="c3" colnum="3" colwidth="1*"/>
            <colspec colname="c4" colnum="4" colwidth="1*"/>
            <colspec colname="c5" colnum="5" colwidth="1*"/>
            <colspec colname="c6" colnum="6" colwidth="1*"/>
            <tbody>
              <row>
                <entry/>
                <entry namest="c2" nameend="c6" align="center"><b>Size (bytes)</b></entry>
              </row>
              <row>
                <entry/>
                <entry align="center">Header</entry>
                <entry align="center">Key</entry>
                <entry align="center">Path</entry>
                <entry align="center">Value</entry>
                <entry align="center">Total</entry>
              </row>
              <row>
                <entry><b>Full document</b>
                  <p>(SET)</p></entry>
                <entry>24</entry>
                <entry>14</entry>
                <entry>-</entry>
                <entry>100,240</entry>
                <entry>100,278</entry>
              </row>
              <row>
                <entry><b>Sub-document</b>
                  <p>(SUBDOC_DICT_ADD)</p></entry>
                <entry>24</entry>
                <entry>14</entry>
                <entry>20</entry>
                <entry>30</entry>
                <entry>88</entry>
              </row>
            </tbody>
          </tgroup>
        </table> In this example, there is a saving of 100,190 bytes using sub-document compared to existing full document operations, or a 99.91% saving in network bandwidth.</p>
      <p>However, this bandwidth saving is only possible because the cluster node performs the additional processing to handle this request. The cluster node needs to parse the current JSON value for "<userinput>user::j.bloggs</userinput>", apply the requested modification (inserting an element into a dictionary in the above example), and then store the result. The exact CPU required for this will vary considerably depending on a number of factors, including: <ul>
        <li>Size of the existing document.</li>
        <li>Complexity (different levels of nesting, etc) of the existing document.</li>
        <li>Type of sub-document operation being performed.</li>
        <li>Size of the fragment being applied.</li>
      </ul> In general, sub-document API is a good fit for applications where network bandwidth is at a premium, and at least one of the following is true: <ul>
        <li>The document being operated on is not very small.</li>
        <li>The fragment being requested/modified is a small fraction of the total document size.</li>
      </ul></p>
    </section>
  </body>
</topic>
