<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="Bitwisefun">
    <title>Bitwise Functions in N1QL</title>
    <body>
        <p>All Bit/Binary functions can only operate on 64-bit signed integers. All non-integer
            numbers and other data types result in null.</p>
        <section id="section_f5c_t55_s1b"><title>BitAND (<varname>int1</varname>,
                    <varname>int2</varname>)</title><p>Returns the result of a bitwise AND operation
                performed on two integer values.</p><p>The bitwise AND operation compares each bit
                    of<varname> int1 </varname>to the corresponding bit of <varname>int2</varname>.
                If both bits are 1, then the corresponding result bit is set to 1; otherwise it is
                set to 0 (zero).</p><p><b>Example</b>: Compare 3 (0011 in binary) and 6 (0110 in
                binary).<codeblock>SELECT BitAND(3,6);

results: [
   "$1": 2
]</codeblock></p>This
            results in 2 (0010 in binary) because only bit 2 is set in both 3 (00<b>1</b>1) and 6
                (01<b>1</b>0).<p><b>Example</b>:  Compare 4.5 and 3 (0011 in
                binary).<codeblock>SELECT BitAND(4.5,3);

results: [
   "$1": null
]</codeblock>This
                results in null because 4.5 is not an integer.</p></section>
        <section id="section_rcg_sbw_s1b"><title>BitCLEAR (<varname>int1</varname>,
                    <varname>position</varname> |
                <varname>position_array</varname>)</title><p>Returns the result after clearing the
                specified, or array of bits, in a given value.</p><p>Specifying a negative or zero
                bit position does not result in any change to the value.<note>Specifying a negative
                    or zero bit position makes the function return a null.</note></p><p>When looking
                at the value in binary form, bit 1 is the Least Significant Bit (LSB) and bit 32 is
                the Most Significant Bit.</p><p>(MSB) Bit 32  → <codeph>0000 0000 0000 0000 0000
                    0000 0000 0000</codeph> ←- Bit 1 (LSB)</p><b>Example</b>:  Clear bit 1 from 6
            (0110 in
            binary).<codeblock>SELECT BitCLEAR(6,1);

results: [
   "$1": 6
]</codeblock>This
            results in 6 (011<b>0</b> in binary) because bit 1 was already zero.<p><b>Example</b>:
                Clear bits 1 and 2 from 6 (01<b>10</b> in
            binary).</p><codeblock>SELECT BitCLEAR(6,[1,2]);

results: [
   "$1": 4
]</codeblock>This
            results in 4 (01<b>0</b>0 in binary) because bit 2 changed to zero.<p><b>Example</b>:
                Clear bits 1, 2, 4, and 5 from 31 (0<b>11</b>1<b>11</b> in
                binary).<codeblock>SELECT BitCLEAR(31,[1,2,4,5]);

results: [
   "$1": 4
]</codeblock>This
                results in 4 (0<b>00</b>1<b>00</b>) because bits 1, 2, 4, and 5 changed to
            zero.</p></section>
        <section>
            <title>BitNOT (<varname>int1</varname>)</title>
            <p>Returns the results of a bitwise logical NOT operation performed on one integer
                value.</p>
            <p>The bitwise logical NOT operation reverses the sense of the bits in the value. For
                each value bit that is 1, the corresponding result bit will be set to 0 (zero); and
                for each value bit that is 0 (zero), the corresponding result bit will be set to
                    1.<note>All bits of the integer will be altered by this operation.</note></p>
            <p><b>Example</b>: Perform the NOT operation on 3 (0000 0000 0000 0000 0000 0000 0000
                0011 in
                binary).<codeblock>SELECT BitNOT(3);

results: [
   "$1": -4
]</codeblock>This
                results in -4 (<b>1111 1111 1111 1111 1111 1111 1111 1100</b> in binary) because all
                bits changed.</p>
        </section>
        <section id="section_lmd_mv5_s1b">
            <title>BitOR (<varname>int1</varname>, <varname>int2</varname>)</title>
            <p>Returns the result of a bitwise inclusive OR operation performed on two integer
                values.</p>
            <p>The bitwise inclusive OR operation compares each bit of int1 to the corresponding bit
                of int2.  If either bit is 1, the corresponding result bit is set to 1; otherwise,
                it is set to 0 (zero).</p>
            <p><b>Example</b>:  Perform OR on 3 (0011 in binary) and 6 (0110 in
                binary).<codeblock>SELECT BitOR(3,6);

results: [
   "$1": 7
]</codeblock>This
                results in 7 (0<b>111</b> in binary) because at least 1 bit of each (00<b>11</b> and
                    0<b>11</b>0) is 1 in bits 1, 2, and 3.</p>
        </section>
        <section id="section_pkl_xld_t1b">
            <title>BitROTATE → see BitSHIFT</title>
            <p>This function is implemented within the <xref href="#Bitwisefun/section_zms_vw5_s1b"
                    format="dita">BitSHIFT</xref> function.</p>
        </section>
        <section id="section_cmz_k4v_s1b">
            <title>BitSET (<varname>int1</varname>, <varname>position</varname> |
                    <varname>position_array</varname>)</title>
            <p>Returns the result after setting the specified bit, or multiple bits, in a single
                value.</p>
            <p>Specifying a negative or zero bit position does not result in any change to the
                value. If the bit is already set, then it stays set. <note>Specifying a negative or
                    zero position makes the function return a null.</note><b>Example</b>: Set bit 1
                in the value 6 (011<b>0</b> in
                binary).<codeblock>SELECT BitSET(6,1);

results: [
   "$1": 7
]</codeblock>This
                results in 7 (011<b>1</b> in binary) because bit 1 changed to 1.</p>
            <p><b>Example</b>: Set bits 1 and 2 in the value 6 (01<b>10</b> in
                binary).<codeblock>SELECT BitSET(6,[1,2]);

results: [
   "$1": 7
]</codeblock></p>
            <p>This also results in 7 (01<b>11</b> in binary) because bit 1 changed while bit 2
                remained the same.</p>
            <p><b>Example</b>: Set bits 1 and 4 in the value 6 (<b>0</b>11<b>0</b> in
                binary).<codeblock>SELECT BitSET(6,[1,4]);

results: [
   "$1": 15
]</codeblock>This
                results in 15 (<b>1</b>11<b>1</b> in binary) because bit 1 and 4 changed to
                ones.</p>
        </section>
        <section id="section_zms_vw5_s1b"><title>BitSHIFT (<varname>int1</varname>,
                    <varname>shift_amount</varname>, <varname>rotate</varname>)</title><p>Returns
                the result of a bit logical left shift or right shift operation performed on an
                integer value. If the input<codeph> shift_amount </codeph>is negative, then it
                represents a right shift; otherwise, it represents a left
                    shift.</p><p><codeph>Rotate </codeph>is an optional argument that defaults to
                FALSE.</p><p><codeph>Rotate </codeph>is a boolean value. If FALSE, then this is a
                logical shift; if TRUE, it is a circular shift (shift-and-rotate operation). Logical
                shift means bits shifted off the end of a value are considered lost. Circular shift
                means that bits shifted off the end of a value are rotated back onto the value at
                the <i>other</i> end. In other words, the bits rotate in what might be thought of as
                a circular pattern; therefore, no bits are ever lost. For comparison, see the below
                table.</p><p>
                <table frame="all" rowsep="1" colsep="1" id="table_wx3_kyc_t1b">
                    <tgroup cols="4" align="left">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="1*"/>
                        <colspec colname="c3" colnum="3" colwidth="4*"/>
                        <colspec colname="newCol4" colnum="4" colwidth="8*"/>
                        <thead>
                            <row>
                                <entry>Input</entry>
                                <entry>Shift</entry>
                                <entry>Result (Rotate FALSE)</entry>
                                <entry>Result (Rotate TRUE)</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>6 (0000 0110)</entry>
                                <entry>4</entry>
                                <entry>96 (0110 0000)</entry>
                                <entry>96 (0110 0000)</entry>
                            </row>
                            <row>
                                <entry>6 (0000 0110)</entry>
                                <entry>3</entry>
                                <entry>48 (0011 0000)</entry>
                                <entry>48 (0011 0000)</entry>
                            </row>
                            <row>
                                <entry>6 (0000 0110)</entry>
                                <entry>2</entry>
                                <entry>24 (0001 1000)</entry>
                                <entry>24 (0001 1000)</entry>
                            </row>
                            <row>
                                <entry>6 (0000 0110)</entry>
                                <entry>1</entry>
                                <entry>12 (0000 1100)</entry>
                                <entry>12 (0000 1100)</entry>
                            </row>
                            <row>
                                <entry><b>6 (0000 0110)</b></entry>
                                <entry><b>0</b></entry>
                                <entry><b>6 (0000 0110)</b></entry>
                                <entry><b>6 (0000 0110)</b></entry>
                            </row>
                            <row>
                                <entry>6 (0000 0110)</entry>
                                <entry>-1</entry>
                                <entry>3 (0000 0011)</entry>
                                <entry>3 (0000 0011)</entry>
                            </row>
                            <row>
                                <entry>6 (0000 0110)</entry>
                                <entry>-2</entry>
                                <entry>1 (0000 0001)</entry>
                                <entry>-9223372036854776000 (1000 0000 ... 0000 0001)</entry>
                            </row>
                            <row>
                                <entry>6 (0000 0110)</entry>
                                <entry>-3</entry>
                                <entry>0 (0000 0000)</entry>
                                <entry>-4611686018427388000 (1100 0000 ... 0000 0000)</entry>
                            </row>
                            <row>
                                <entry>6 (0000 0110)</entry>
                                <entry>-4</entry>
                                <entry>0 (0000 0000)</entry>
                                <entry>6917529027641081856 (0110 0000 ... 0000 0000)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </p><p><b>Example 1</b>: Shift the bits of 6 (0110 in binary) one bit to the
                left.<codeblock>SELECT BitSHIFT(6,1,FALSE);

results: [
   "$1": 12
]</codeblock></p><p>This
                results in 12 (1100 in binary) because the 1-bits moved from positions 2 and 3 to
                positions 3 and 4.</p><p><b>Example 2</b>: Shift the bits of 6 (0110 in binary) two
                bits to the
                right.<codeblock>SELECT BitSHIFT(6,-2);

results: [
   "$1": 1
]</codeblock>This
                results in 1 (0001 in binary) because the 1-bits moved from positions 2 and 3 to
                positions 1 and "0" but there is no "bit 0" so that bit was simply
                dropped.</p><b>Example 2b</b>: Shift the bits of 6 (0110 in binary) two bits to the
            right, with Rotate set to
            TRUE.<codeblock>SELECT BitSHIFT(6,-2, TRUE);

results: [
   "$1": -9223372036854776000
]</codeblock>This
            results in -9223372036854776000 (1100 0000 0000 0000 0000 0000 0000 0000 in binary)
            because the 1-bits "wrapped around" to the Most Significant Digit position and changed
            the integer's sign to negative.</section>
        <section id="section_unf_2sv_s1b"><title>BitTEST (<varname>int1</varname>,
                    <varname>position</varname> | <varname>position_array</varname>,
                    <varname>all_set</varname>)</title><p><codeph>BitTEST() </codeph>and<codeph>
                    IsBitSet() </codeph>are the same, and they return TRUE if the specified bit, or
                bits, is a 1; otherwise, they return FALSE if the specified bit, or bits, is a 0
                (zero).</p><p>
                <note>Specifying a negative or zero bit position will result in 0 (zero) being
                    returned.</note>
            </p><p>When looking at the value in binary form, bit 1 is the Least Significant Bit
                (LSB) and bit 32 is the Most Significant Bit.</p><p>(MSB) Bit 32 → <codeph>0000 0000
                    0000 0000 0000 0000 0000 0000</codeph> ←- Bit 1 (LSB)</p><p><codeph>all_set
                </codeph>[optional] is a boolean value that is TRUE by default. TRUE means "all"
                values; and FALSE means "any" value.</p><p>When<codeph> all_set </codeph>is FALSE,
                then it returns TRUE even if one bit in one of the positions is
                    set.</p><p>When<codeph> all_set </codeph>is TRUE, then it returns TRUE only if
                all input positions are set.</p><p><b>Example</b>: In the number 6 (0110 in binary),
                is bit 1
                set?<codeblock>SELECT IsBitSET(6,1);

results: [
   "$1": FALSE
]</codeblock>This
                returns FALSE because bit 1 of 6 (011<b>0</b> in binary) is not set to
                    1.</p><p><b>Example</b>:  In the number 1, is either bit 1 or bit 2
                set?<codeblock>SELECT BitTest(1,[1,2],FALSE);

results: [
   "$1": TRUE
]</codeblock>This
                returns TRUE because bit 1 of the number 1 (000<b>1</b> in binary) is set to
                    1.</p><p><b>Example</b>:  In the number 6 (0110 in binary), are both bits 2 and
                3
                set?<codeblock>SELECT IsBitSET(6,[2,3],TRUE);

results: [
   "$1": TRUE
]</codeblock></p>This
            returns TRUE because both bits 2 and 3 in the number 6 (0<b>11</b>0 in binary) are set
            to 1.</section>
        <section id="section_qvr_2w5_s1b">
            <title>BitXOR (<varname>int1</varname>, <varname>int2</varname>)</title>
            <p>Returns the result of a bitwise Exclusive OR operation performed on two integer
                values. </p>
            <p>The bitwise Exclusive OR operation compares each bit of value1 to the corresponding
                bit of value2. If one bit is 0 (zero) and the other bit is 1, the corresponding
                result bit is set to 1; otherwise, the corresponding result bit is set to 0
                (zero).</p>
            <p><b>Example</b>:  Perform the XOR operation on 3 (0011 in binary) and 6 (0110 in
                binary).<codeblock>SELECT BitXOR(3,6);

results: [
   "$1": 5
]</codeblock>This
                returns 5 (0101 in binary) because there is only 1 bit set on bits 1 and 3
                    (0<b>0</b>1<b>1</b> and 0<b>1</b>1<b>0</b>).</p>
        </section>
        <section id="section_t4m_pmb_t1b">
            <title>IsBitSET → see BitTEST</title>
            <p>This function is implemented within the <xref href="#Bitwisefun/section_unf_2sv_s1b"
                    format="dita">BitTEST</xref> function.</p>
        </section>
    </body>
</topic>
