<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="topic_11_7" xml:lang="en-US">
  <title id="title__Toc272567428">SELECT statement</title>
  <conbody >
 
    <p>SELECT statements let you retrieve data from specified keyspaces. A simple query in N1QL has
      three parts to it:</p>
    <ul>
    <li>SELECT - Parts of the document to return in an array.</li>
    <li>FROM - The keyspace, or datastore with which to work. </li>
    <li >WHERE - Conditions the data must satisfy to be retrieved.</li>
    </ul>
    
    <p>Only a SELECT clause is required in a query. </p>
    <p >Because the data is stored in documents rather than rigidly structured tables, queries can return a collection 
      of different document structures or fragments. The one requirement is that the retrieved data will match the 
      conditions in the WHERE clause, if one is provided.</p>
    <p>Exercising the full power of the SELECT statement is more complex. With the SELECT statement,
      you can retrieve any data from a keyspace. Once retrieved you can specify how you want the
      data returned. You can also manipulate the data in the result set, and, using data
      manipulation statements, you can modify the data in the actual keyspace.</p>
    <section><title>SELECT Statement Processing</title>
      <p>The SELECT statement queries a keyspace. A JSON array is returned that contains zero or more
        result objects. SELECT behaves as a sequence of steps in a process. Each step in the process
        produces result objects that are then used as inputs in the next step until all steps in the
        process are complete. The possible elements and operations in a query include: </p>
      
      <ul>
        <li><b>Specifying the Keyspace:</b> You specify the keyspace that is queried. This is the
          from-path parameter in a FROM clause. You can also provide a path as keyspace.</li>
        <li><b>Filtering the Results:</b> You can filter result objects from the SELECT by specifying a condition in the WHERE clause.</li>
        <li><b>Generating a Result Set:</b> You can generate a set of result objects with GROUP BY or
          HAVING clauses along with a result expression list, result-expression-list.</li>
        <li><b>Removing Duplicates:</b> You can remove duplicate result objects from the result set by using the DISTINCT clause.</li>
        <li><b>Ordering Items in the Result Set:</b> You can sort items in the order specified by the ORDER BY expression list.</li>
        <li><b>Skipping Results:</b> You can skip the first <i>n</i> items as specified by the OFFSET clause</li>
        <li><b>Limiting the Number of Results:</b> You can specify the maximum number of items returned with the LIMIT clause.</li> </ul>
    </section>
    <section><title>SELECT Statement Syntax</title>
      <p><i>select:</i></p>
      
      
      <codeblock>subselect [ set-op ([ALL] )  subselect]* [order-by-clause] [limit-clause]  [offset-clause]
      </codeblock>
      
      <p><i>set-op:</i></p>
      <codeblock>UNION | INTERSECT | EXCEPT
      </codeblock>
      
      <p><i>subselect:</i></p>
      <codeblock>select-from | from-select
      </codeblock>
      
      <p><i>select-from:</i></p>
      <codeblock>select-clause [from-clause] [let-clause] [where-clause] [group-by-clause] 
      </codeblock>
      
      <p><i>from-select:</i></p>
      <codeblock>from-clause [let-clause] [where-clause] [group-by-clause] select-clause  
      </codeblock>
      
      <p><b>SELECT Clause</b></p>
      <p><i>select-clause:</i></p>
      <codeblock>SELECT ( [ALL | DISTINCT]  ( result-expression [, result-expression]*) | 
        (RAW | ELEMENT) expression)
      </codeblock>
      
      <p><i>result-expression:</i></p>
      <codeblock>[(path .)] * | expression [ ([AS] alias) ]
      </codeblock>
      
      <p><i>path:</i></p>
      <codeblock>identifier [<b>[</b> expression <b>]</b>]  [. path]  
      </codeblock>
      
      <p><i>alias:</i></p>
      <codeblock>identifier
      </codeblock>
      
      <p><b>FROM clause</b></p>
      <p><i>from-clause:</i></p>
      <codeblock>FROM from-term
      </codeblock>
      
      <p><i>from-term:</i></p>
      <codeblock>from-path [([AS] alias)] [use-keys-clause] | from-term join-clause | from-term nest-clause | from-term unnest-clause 
      </codeblock>
      
      <p><i>from-path:</i></p>
      <codeblock>[(namespace :)] path
      </codeblock>
      
      <p><i>namespace:</i></p>
      <codeblock>identifier
      </codeblock>
      
      <p><i>use-keys-clause:</i></p>
      <codeblock>USE [PRIMARY] KEYS expression
      </codeblock>
      
      <p><i>join-clause:</i></p>
      <codeblock>[join-type] JOIN from-path [( [AS] alias) ] on-keys-clause  
      </codeblock>
      
      <p><i>join-type:</i></p>
      <codeblock>INNER | LEFT [OUTER]
      </codeblock>
      
      <p><i>on-keys-clause:</i></p>
      <codeblock>ON [PRIMARY] KEYS expression
      </codeblock>
      
      <p><i>nest-clause:</i></p>
      <codeblock>[join-type] NEST from-path [ ( [AS] alias) ] on-keys-clause 
      </codeblock>
      
      <p><i>unnest-clause:</i></p>
      <codeblock>[join-type] [UNNEST | FLATTEN] expression [ ( [AS] alias) ]
      </codeblock>
      
      <p><b>LET clause</b></p>
      <codeblock>LET (alias = expression) [, (alias = expression)]*
      </codeblock>
      
      <p><b>WHERE clause</b></p>
      <p><i>where-clause:</i></p>
      <codeblock>WHERE condition
      </codeblock>
      
      <p><i>cond:</i></p>
      <codeblock>expression 
      </codeblock>
      
      
      <p><b>GROUP BY clause</b></p>
      <p><i>group-by-clause:</i></p>
      <codeblock>GROUP BY expression [ , expression ]* [ letting-clause ] 
        [having-clause] ] | [letting-clause] 
      </codeblock>
      
      <p><i>letting-clause:</i></p>
      <codeblock>LETTING  alias = expression [(, alias = expression) ]*
      </codeblock>
      
      <p><i>having-clause:</i></p>
      <codeblock>HAVING condition
      </codeblock>
      
      <p><b>ORDER BY clause</b></p> 
      <p><i>order-by-clause:</i></p>
      <codeblock>ORDER BY ordering-term [, ordering-term]* 
      </codeblock>
      
      <p><i>ordering-term:</i></p>
      <codeblock>expression [ASC | DESC]
      </codeblock>
      
      <p><b>LIMIT clause</b></p>
      <codeblock>LIMIT expression
      </codeblock>
      
      <p><b>OFFSET clause</b></p>
      <codeblock>OFFSET expression 
      </codeblock>
    </section>
  </conbody>
</concept>
